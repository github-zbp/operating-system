什么是操作系统

操作系统是管理计算机软件和硬件的程序。
所以本质上，操作系统是一个程序，软件。

具体功能有配置内存，决定资源供需顺序，控制输入输出设备，提供操作界面

高度概括就是：操作系统是管理软硬件，配置资源和供用户交互的软件系统


为什么需要操作系统
因为我们不可能直接操作硬件
因为设备种类繁多，要统一界面


操作系统的基本功能
CPU资源，存储器资源，IO设备资源和文件资源。操作系统同一管理这些计算机资源。例如我们读写文件，不可能直接操作硬盘，而是通过操作系统去硬盘获取。（操作系统同一管理计算机资源）

有了操作系统，我们无需面向CPU，硬盘等硬件进行编程。只需面向操作系统编程即可。（操作系统实现了对计算机资源的抽象）

操作系统提供了用户和计算机之间的交互接口


操作系统的相关概念
并发性
共享性
虚拟性
异步性

并发性是后面三个概念的基础

并行和并发
并行是多个事件可以在同一时刻发生
并发是多个事件可以在同一时间间隔交替发生

并行和并发在计算机中的体现
对于单核处理器而言，一个核心在同一时刻只能运行一个程序，所以如果单核处理器要运行多个程序，只能对每一个程序设置一小段时间片,让多个程序按照时间片规定时间交替运行，这就是并发（程序A运行时间片内规定的时间，再让程序B运行时间片规定的时间，再让A运行规定时间，如此循环，从而达到单处理器“同时”运行多个程序的效果，但其实CPU不是同一时刻运行多个程序）

对于多核处理器，处理器的一个核在同一时刻还是只能运行一个程序，因此在一个核心的内部，程序还是并发的。核心与核心之间，程序是并行的。

PS: 一个计算机可以有多个处理器,处理器又分为单核处理器和多核处理器
单核处理器只能并发不能并行处理程序
多核处理器由于有多个核心,所以一个处理器也能并行处理程序
计算机如果有多个单核处理器或者一个多核处理器,都是可以并行执行程序的

4个单核处理器和一个4核的处理器的速度相比,后者更快,因为后者的4个核心是放在一块芯片上的(放在一个CPU上),其数据是共享的,进程通信和交互更快


概括起来就是：
并发是多个程序可以同时运行，但不是同一时刻运行
并行是多个程序同一时刻运行


共享性
共享性表现为操作系统的资源可供并发的多个程序共同使用

共享性可以分为互斥共享形式和同时访问形式
互斥共享就是程序A使用资源时对资源上锁，其他程序无法使用该资源，等到A使用完毕并释放资源程序B才可以使用该资源。
同时访问是某一资源在一段时间内并发的被多个程序访问。即同一时间段内多个程序交替使用某一资源

所以同时访问也不是多个程序能同一时刻使用同一资源

什么时候会是互斥共享，什么时候会是同时访问？
要根据使用的资源而定。例如多个程序使用磁盘就是同时访问，多个程序使用打印器就是互斥共享

虚拟性
虚拟性表现为将一个物理实体转变为若干个逻辑实体
物理实体真实存在，逻辑实体是虚拟的

虚拟的技术有时分复用技术和空分复用技术


时分复用就是不同程序并发使用资源，多道程序分时交替使用计算机的硬件资源。例如，在单处理器中，多个程序会交替执行，交替使用处理器资源。这样可以提高资源利用率。

时分复用技术包括虚拟处理器技术和虚拟设备技术

虚拟处理器技术是：
为每个程序建立进程，多个程序分时复用处理器（交替运行）

虚拟设备技术是：
物理设备虚拟为多个逻辑设备
每个程序占用一个逻辑设备
多个程序通过逻辑设备并发访问这个物理设备


空分复用技术包括虚拟磁盘技术和虚拟内存技术
虚拟磁盘技术就是将一块物理硬盘在逻辑上分成多个逻辑盘（C盘，D盘，E盘），这样其中一个逻辑盘遭到破坏也不会影响到其他逻辑盘

虚拟内存技术，就是程序运行时需要大量内存存储数据,但是有部分数据是不经常使用的,此时这部分数据会放到磁盘而不是内存中。如果需要使用到这部分不经常使用的数据才会将其从磁盘交换到内存中。
虚拟内存技术在逻辑上扩大程序的存储容量，使程序可以使用到比实际内存更多的内存量。

对于虚拟化，可以理解为分身术。

异步性
其实还是指多个进程可以并发执行
进程的执行不是一气呵成的，而是走走停停的形式推进。还是以使用资源为例，某个进程执行到某一步时需要使用某一资源，如果这个资源被其他进程占用，进程就会停止或者等待。此时进程不会一直占用CPU，而是会让出CPU给其他进程使用，即使这个等待的进程的时间片没有使用完。




===========================================

进程（Process）

为什么需要进程
在没有操作系统的时代，计算机只能运行完一个程序再运行下一个程序（顺序执行），而资源也只属于当前运行的程序。而当前程序可能只用了资源的一部分，但是由于资源也只属于当前运行的程序，所以其他程序不能使用该资源的其他部分造成资源浪费。
操作系统出现后，就引入了多道程序设计的概念。进程的出现就是为了合理隔离资源提高资源使用效率

进程是系统进行资源分配和调度的基本单位
进程是程序独立运行的载体

这样说吧，有了进程，多个程序才可以共享资源（存储器，CPU等），使得计算机的资源利用率大大提高
为什么说有了进程多个程序就可以共享资源
因为进程是并发的交替执行的,所以进程使用资源时也是交替使用;而没有进程,程序是顺序执行的,一个程序运行完了才轮到下一个程序运行,意味着一个程序对资源使用完毕才能给下一个程序使用,相当于独占资源

进程的实体（进程到底长什么样子的）
a.主存中的进程形态
在主存中，进程的形态是一段连续存储的空间（一个字块或多个字块组成的块），这个空间叫做进程控制块（PCB），这个控制块用来记录进程的相关信息。

在这个控制块中，包含以下信息：
标识符：作为一个进程的唯一标记，即pid（进程id）
状态：如，运行状态还是阻塞状态等
程序计数器：指向进程即将执行的下一条指令的地址
内存指针：程序代码，进程数据相关指针
上下文数据：存储着进程执行时，处理器存储的数据（寄存器和高速缓存中的数据）
IO状态信息：记录着被进程IO操作所占用的文件，是一个列表结构
记账信息：记录进程使用处理器的时间，时钟数总和等
还有其他的信息。

PCB是描述和控制进程运行的通用数据结构
PCB使得一个进程成为独立运行的基本单位。
进程被调度具体表现为PCB被操作系统读写
PCB是常驻内存的

高度概括：进程就是内存中的一段连续存储空间(PCB)。PCB记录着进程的所有信息。进程被调度的过程就是PCB被读写的过程。

线程（Thread）
线程是操作系统进行运行调度的最小单位
线程是包含在进程当中的，是进程中实际运行和工作的单位
一个进程可以并发多个线程，每个线程执行不同的任务。

也就是说一个进程运行其实是该进程的多个线程在交替运行
操作系统运行一个进程其实是运行这个进程中的线程
一个进程要完成的是一个大任务，而一个个线程将这个大任务切割为一个个小任务，每个线程完成一个小任务。 

进程和线程是一对多关系，一个进程至少有一个线程。
进程是一个存储空间是一个仓库，而线程是仓库中的工人

一个进程内的所有线程可以共享进程的资源（可以使互斥共享形式的共享或者同时访问形式的共享）


比较
	进程	线程
资源	资源分配的基本单位	不拥有资源（想要资源得从进程中取）
调度	独立调度的基本单位（调度进程实际是调度进程中的线程）	独立调度的最小单位
开销	开销大（因为要管理线程和分配资源）	开销小(因为同一进程的线程资源是共享的)
通信	进程IPC	通过读写同一进程数据来通信



进程的5个状态
就绪
阻塞
执行
创建
终止 

就绪状态：进程被分到除了CPU资源外的所有必要资源的状态
只要在获取CPU的使用权就可以立刻运行

系统中多个处于就绪状态的进程会排成一个队列，叫做就绪队列。

执行状态：就绪队列中的进程获取CPU后，其程序正在执行则称这个进程为执行状态。
单处理器中，某个时刻只能有一个进程处于执行状态。
如果计算机只有一个CPU，该计算机某时刻只有一个进程处于执行状态。

阻塞状态：当进程因为某种原因而放弃占用CPU的状态叫阻塞状态。某种原因如：其他设备或资源由于被其他进程占用而未就绪导致无法继续执行

处于阻塞状态的进程会被放入阻塞队列中。


多个并发的进程，同一时刻只有一个进程处于执行状态，其他进程都是就绪状态或阻塞状态。


就绪，执行和阻塞状态的切换：

就绪进程都放在就绪队列中。
当轮到某进程被系统调度时，该就绪进程会从就绪队列被弹出，被分配时间片，并占用CPU进行程序运行。此时进程变为执行状态
当进程运行完时间片规定的时间后，进程会回到就绪队列中，由执行状态改为就绪状态，CPU被下一个进程使用。


在进程执行过程中，如果进程发送IO请求遇到阻塞(资源被其他进程锁住)或者执行磁盘IO读写时，(即使这个进程的时间片没用完)该进程也会主动让出CPU给其他进程使用，改执行状态的进程会变成阻塞状态的进程。
当IO完成后，阻塞进程会被唤醒变成就绪进程等待CPU的下一次调度。


创建状态：进程创建包括两步：创建PCB和进入就绪队列。
创建进程时拥有PCB但其他资源尚未分配好的状态。
操作系统提供了fork函数让我们可以创建进程。

终止状态：进程归还PCB后的状态。




在这里顺便说一下IO操作和CPU操作:


IO设备根据用途分为3类:

人机交互类外部设备,简称外部设备,如打印机、显示器、鼠标、键盘等。这类设备数据交换速度相对较慢

存储设备,如磁盘,光盘(不包括内存)

网络通信设备,用于和远程设备通信的设备,如网络接口

速度:存储设备>网络通信设备>人机交互外部设备

所以以前的一个重要误区是认为IO设备就是磁盘,其实不只磁盘


根据共享方式不同分为
独占式使用设备,只能以互斥共享的方式共享的IO资源设备,如打印机

分时共享使用设备,能以同时访问的方式共享的IO资源设备,如磁盘

虚拟设备,未知

IO操作和CPU操作的关系:
以磁盘为例,每一个磁盘都会安装一个DMA硬件(DMA是一种叫做直接内存访问的技术,该技术使得辅存可以直接读写内存,和内存交换数据而无需CPU的参与)
这个DMA硬件使得磁盘具有DMA技术和功能,而这个DMA硬件就像一个安装在磁盘的"小型CPU"
这个DMA处理器具体功能就是,当一个进程要进行磁盘IO操作的时候,CPU会向磁盘发送IO请求,DMA处理器接受请求后,由DMA处理器负责进行IO操作(也就是从内存读写数据到磁盘,或者从磁盘读写数据到内存),在这个过程中,CPU不会去参与IO操作,而是继续执行其他进程。原因是IO操作很慢，CPU不能一直这样等下去。
当IO操作完成后，DMA硬件通过总线发送一个中断指令给CPU，CPU就会去内存中读取(磁盘写入进内存的)数据,并交由进程使用

也就是说由于IO操作而进入阻塞状态中的进程其实是在等待IO操作完成
而此时CPU是在为其他进程服务,没有参与IO操作
CPU唯一和IO交互的时刻就是发送IO请求和接受IO响应

结论是:IO操作和CPU操作是异步的

============================

进程同步

生产者消费者模型
有一群生产者进程生产产品，并将这些产品提供给消费者进程进行消费。生产者和消费者可以并发执行，两者之间设置了一个缓冲区池，生产者进程将生产的产品放到一个缓冲区，消费者进程可以从缓冲区取走消费者。

假设有三个生产者进程和三个消费者进程，生产者做的事情是对缓冲区的一个数据k进行+1，而消费者要进行-1

由于缓冲区是在缓存（高速缓存）中，对缓冲区的数据进行修改需要将缓冲区的数据拷贝一份到CPU寄存器操作才行。
所以生产者的操作是
register = k    # 数据拷贝一份到寄存器
register = register+1   # 寄存器内数据+1，这一步是在CPU中执行,左边的register是放在寄存器暂存的
k = register    # 将寄存器的数据覆盖到缓冲区


6个进程(或者线程)，共18个操作，这6个进程是并发的，这会导致上面的18个操作会同时（同一时间间隔）发生而导致混乱

例如 
            register    k
生产者进程1   10       10     register=k(将缓存读取到进程1中的寄存器)
生产者进程1   11       10     register=register+1
消费者进程2   10       10     register=k(将缓存读取到进程2中的寄存器，缓存中的k还是10，因为进程1还未将register写入缓冲区中)

消费者进程2   9       10     register=register-1 
消费者进程2   9       9      k=register  (进程2的register写入缓存)
生产者进程1   11        11   k=register（进程1register写入k）

按理说 进程1对k+1,进程2对k-1，结果k还是10，最后k是11（脏读）

原因是这多个进程是并发执行，却没有互相通信，最后导致缓冲区的数据混乱。


哲学家进餐问题
情景如下：五个哲学家，其生活方式是交替的进行思考（就绪状态）和进餐（执行状态），他们共坐在一个圆桌上，有5个碗和五根筷子。平时哲学家思考，饥饿就会进餐。
进餐时，一个哲学家会先拿他左边的筷子，再拿它右边的筷子。只有拿到左右两根筷子才会进餐。如果只拿到左边的筷子，但右边的筷子被别的哲学家拿了，就只有等待右边的筷子被释放这个哲学家才能进餐（阻塞状态）。

有个极端情况：
如果5个哲学家都饿了，同时拿起了左边的筷子，想拿右边的筷子时发现右边的筷子都被拿走了。
此时5个哲学家都会等待，一直等一直等，最后5个哲学家都饿死了。（死锁）

筷子就是资源，哲学家就是进程。


上面生产者消费者模型和哲学家进餐问题出现的原因是：
1.进程是并发执行的
2.彼此间没有通信

进程间的同步作用就是对竞争资源在多进程间的使用进行次序协调。使并发执行的多个进程之间可以有效的使用资源和合作。

在上面的生产者消费者模型和哲学家进餐中，主存和“筷子”都是临界资源。
临界资源指：一些虽作为共享资源却无法同一时刻被多个进程或线程共同访问的资源。
当进程或线程在使用临界资源时，其他进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可以重新竞争使用共享资源。

高度概括：临界资源是一种共享资源（可以被互斥共享或同时访问的形式共享），却无法被多个进程或线程同一时刻访问。


进程同步原则
空闲让进：若资源没有被占用，操作系统会允许某进程使用这个资源
忙则等待：资源有占用，请求进程要等待
有限等待：虽然资源被占用，但是资源不能一直被一个进程占用导致其他进程一直等待。该原则保证某进程是有限时间的等待就能使用资源
让权等待：进程等待时需要让出CPU（执行状态变为阻塞状态）


进程间同步的方法：
1.消息队列
2.共同存储
3.信号量


线程间同步
我们知道，多个线程在进程中也是每个线程分配时间片交替执行，共享资源的。
当多线程并发使用进程资源，也同样会发生上面的生产者消费者问题和哲学家进食问题，所以同一个进程中的线程间也需要同步。

线程同步的方法：
1.互斥量
2.读写锁
3.自旋锁
4.条件变量



=================================

Linux进程管理


Linux进程相关概念

在Linux中，进程分为三种类型：
前台进程是具有终端，可以和用户交互的进程。前台进程会占用整个终端（就是shell命令行界面）

后台进程是没有占用终端的进程。
后台程序基本不和用户交互，优先级比前台进程低
在执行的命令后面加一个&就可以变成一个后台进程

后台进程无法通过ctrl+c结束，可以通过kill结束

守护进程(daemon)是特殊的后台进程，他会一直运行直到系统关闭。
进程名字以“d”结尾的一般都是守护进程，如mysqld,httpd,crond,sshd
守护进程也可以通过kill结束


进程ID
进程ID是进程的唯一ID，表现为非负整数，最大的pid由操作系统决定。

进程的父子关系
一个进程可以通过操作系统的fork函数创建一个子进程。
父子进程关系可以通过pstree命令查看

pid为0的进程为idle进程，是系统创建的第一个进程
pid为1的进程为init进程，是0号进程的子进程，用于完成系统初始化
init进程是所有用户进程的祖先进程。所有的初代用户进程都是由init进程产生的。


进程的状态标记
R 处于运行的状态
S 睡眠状态
D 等待IO的睡眠状态
T 暂停状态
Z 正在退出状态或僵尸进程


操作进程的命令
ps
ps -aux --sort=-pmem    # 按使用内存排序
ps -aux --sort=-pcpu    # 按使用cpu排序

top
kill/pkill


要始终记住一件事:进程在阻塞或者等待的时候是会让出CPU的,不会一直占用CPU的

PS：如果系统对一个进程创建多个子进程，他会为每个子进程拷贝一份主进程的数据，资源和（内存）空间，并且每个进程间的资源和空间是独立的互不干扰的。所以进程间数据不共享。
而一个进程创建多个线程，这些线程共用一个进程的数据和资源。所以多线程间，数据和资源是共享的（共享一个进程的）

体现为： A进程有变量x
如果A创建了a,b,c线程,线程a,b,c共享变量x，线程a对x修改，再在b中查看x是看到的改变后的x
如果A创建了A1,A2两个子进程，那么系统会多开出两块空间和资源分给这两个进程，所以A1,A2也会有属于自己的x。A,A1和A2三个进程各自有一个x变量，A改变自己的x不会影响A1的x。

因为创建一个子进程，系统会复制一份和父进程一样大的空间和资源，而创建线程不用系统新分配资源，所以多进程的开销大于多线程

当线程或者进程执行到有阻塞等待（如sleep,文件IO操作）的情况时，即使该线程或进程的时间片没有使用完，也会主动让出CPU给他线程进程使用，自己则进入休眠状态，别的进程线程进入运行状态。
===================================

作业管理之进程调度

进程调度是指：计算机通过决策算法决定哪个就绪进程可以获得CPU的使用权

进程调度有两步：
1是保留旧进程的运行信息，请出旧进程
2是选择新进程，准备运行环境并分配CPU

进程调度的机制：
1.就绪队列的排队机制
为了方便进程调度，会创建一个就绪队列放就绪进程

2.选择运行进程的委派机制
系统会根据算法策略从就绪队列选出进程来分配CPU资源并执行

3.新老进程的上下文切换机制
进程从执行状态变为就绪状态时，系统会保存该进程在CPU的环境（上下文），上下文会从CPU的高速缓存保存到主存中；进程从就绪状态变为执行状态会将上次保存的上下文信息载入，体现为上下文从主存载入到CPU高速缓存中。


非抢占式调度：处理器一旦分配给某个进程，该进程一直使用处理器不让出。直到进程完成工作或者由于IO阻塞才会让出CPU
抢占式的调度：允许调度程序以一定的策略暂停当前运行的进程，保存好旧进程的上下文，分配处理器给新进程。这也是我们常说的多进程根据时间片交替运行的方式。

对比
	抢占式	非抢占式
开销	频繁切换，开销大	切换少，开销少
公平性	相对公平	不公平
应用	通用系统	专用系统

抢占式调度可以让多个进程交替使用CPU资源，相对公平
非抢占式调度会让不在执行的进程一直使用不到CPU，不公平


进程调度算法
1.先来先服务算法
先进入就绪队列的进程先运行

2.短进程优先调度算法
调度程序优先选择就绪队列中估计运行时间最短的进程
该算法不利于长作业进程的运行

3.高优先权优先调度算法
每一个进程都有其优先级，调度进程优先选择权重的进程运行
该算法可以使紧迫的任务可以优先执行
前台进程的优先级高于后台进程

4.时间片轮转调度算法
按照先来先服务的原则排列好就绪进程
每次从队列头部取出待执行进程，分配一个时间片执行，执行完时间片规定的时间就会让出CPU，并将该进程插入队列尾部等待下一次调度
该算法是最公平的调度算法，但是不能保证及时响应用户



作业管理之死锁
死锁是指，两个或以上的进程在执行过程中由于竞争资源或者彼此通信问题造成的阻塞现象，若无外力作用，两个进程都无法进行下去。

死锁产生的原因：竞争资源（资源不足），进程调度顺序不当

例如有两个进程A，B
A已经占用了打印机资源，但是他还需要获取传真机资源
B已经占用了传真机资源，但是他还需要获取打印机资源

A和B各自等待对方将自己所需的资源释放出来，但是等待过程中A和B都不释放自己所占用的资源。

如果此时系统中多一个传真机或者打印机，死锁就不会发生
或者A先申请获取打印机再申请传真机，完了之后再让B申请传真机再申请打印机，按照这个顺序调度也不会发生死锁

死锁产生的4个条件
互斥条件
进程对资源的使用是排他性的，资源同一时刻无法被多个进程同时使用

请求保持条件
进程至少保持一个资源有提出新资源的请求，新资源被占用请求被阻塞，被阻塞的进程不释放自己占用的资源

不可剥夺条件
资源在使用完毕之前，其他进程不能抢夺该资源

环路等待条件
发生死锁时，必然存在进程-资源环形链

只需破坏4个条件中后三个条件中的任意一个就能防止死锁。


银行家算法也可以防止死锁。

========================================

存储管理之内存分配和回收

存储管理的目的：
确保计算机有足够内存来保存和处理数据
确保程序可以从可用内存中获取一部分内存来使用
确保程序可以归还使用后的内存以供其他程序用


内存分配的过程
固定分区分配
将内存划分为若干个固定大小的区域，每个分区只提供给一个程序使用，互不干扰。
固定分区分配是支持多道程序的最简单的内存分配方式

动态分区分配
根据进程实际需要，动态分配相应大小内存空间

首先一个内存会划分为一个个小的分区。
这些内存分区有些是空闲的未被使用的，有些是正在被程序们使用的。

系统会用两种数据结构存放分区，分别是表和双向链表
表存放的是分区的分区id和改分区是否被使用（0或1）。
如：
分区  1 2 3 4 5 6 7 8
标记  0 1 1 1 0 0 1 0 

双向链表只存放空闲的分区,连续的空闲分区作为链表的一个节点
假设内存有10块分区，空闲分区为1,3,4,6,9,10，非空闲区为2,5,7,8
双向链表的结构和节点为：
1<--->3,4<--->6<--->9,10

相邻的空闲区会被当成整体作为一个节点（如3,4是一个节点,6是一个节点,9,10是一个节点），因此链表中的每个节点可能包含一个空闲区，也可能包含多个空闲区
所以链表中的每个节点的容量不同。
所以每个节点需要记录该节点存储的容量


动态分区分配算法
首次适应算法（FF算法）
分配内存是，要从链表头部开始遍历，如果找到了适合某进程所需内存容量的节点就会分配内存给该进程。如果遍历了整个链表都找不到合适的节点则分配失败。

例如：
空闲链表：1<--->3,4,5<--->7<--->9,10
有一个进程需要2个空闲区大小的内存空间
当遍历到第二个节点，发现合适，此时会从节点2将2个空闲区给进程使用,这两个空闲区变成非空闲区。
此时空闲链表变为 1<--->5<--->7<--->9,10

由于每次都是从头部开始遍历，导致靠近链表头部的空闲区被不断划分，形成很多内存碎片（例如刚刚节点2的空闲区从3,4,5变成5）。导致头部的空闲区是不连续的，之后的进程要遍历到链表尾部才能从合适的节点拿到内存空间

循环适应算法是首次适应算法的改进，其下一次遍历不是从头开始，而是从上一次找到合适节点的位置开始往下遍历。


最佳适应算法
该算法要求空闲区链表按照容量大小排序，再遍历空闲区链表找到合适的空闲区节点

例如
1<--->3,4<--->6<--->9,10
会先排序为
1<--->6<--->3,4<--->9,10

这种算法的好处是避免“大材小用”，避免形成过多的内存碎片。原因是所需内存少的进程在链表前半部分就能找到合适的空闲节点，就不会去分割大块内存


快速适应算法
将不同容量的空闲节点放到不同的链表。为进程分配内存的时候，只需找到进程所需内存对应大小的那条链表，在那条链表找获取内存分区即可。减少了遍历的过程。

例如： 
1<--->4<--->8
2,3<--->9,10<--->14,15
5,6,7<--->11,12,13



内存回收的过程
分为四种情况：
空闲区，回收区
回收区，空闲区
空闲区，回收区，空闲区
回收区 

第一种情况，空闲区和回收区相邻，且回收区在空闲区之后。
例如 1<--->4<--->8
此时分区5要回收到内存中，就变成了 1<--->4,5<--->8
此时节点2的空间容量扩大，但是节点2的地址不变，还是指向空闲区4的地址空间

第二种情况如
1<--->4<--->8
分区3要回收到内存中，就变成了 1<--->3,4<--->8
此时节点2的空间容量扩大，但是节点2的地址变成空闲区3的地址

第三种情况如
1<--->4<--->6<--->8
分区5要回收到内存中，就变成了 1<--->4,5,6<--->8
此时节点2的空间容量扩大，但是节点2的地址不变，总结点数变少，节点3的地址从空闲区6变成指向空闲区8

第四种情况
1<--->4<--->8
分区6要回收到内存中，就变成了 1<--->4<--->6<--->8
此时往链表插入新节点即可


当然系统中不可能只有一条空闲链表，而是有很多条。假如在某条空闲链表中找不到符合某进程所需的内存节点（例如进程需要10个分区的空间，但是这条链表里面的所有节点大小都小于10个分区），这个进程就会到其他空闲链表去找
===========================================

存储管理之段页式存储管理

这节主要是介绍进程怎么管理内存的。

页式存储管理
页面：页面和字块一样是内存中的一小块空间
字块是相对物理设备的定义
页面是相对逻辑空间的定义
但是其实字块和页面指的是大小一样的两块内存
页面是进程空间的定义

页式存储管理是将进程逻辑空间等分为若干页面
将物理内存空间分为和页面大小相等的物理块
以页面为单位将进程空间装进物理内存中分散的物理块

也就是说将进程分成很多页，将每一页装进内存的每一个物理块中。每一个物理块（字块）都存放着一页（进程空间的一部分）

这里的一页就是上面空闲链表中的一个分区。

内存碎片
上一节说到内存的空闲区会被放到一个双向链表，并且相邻的空闲区会作为链表的一个节点。
当进程的页面大小要占3个分区的大小，但是链表中没有3个分区大小的节点却有4个分区的节点，所以就要找到链表中4个分区大小的节点用来存储这个页面。3个分区会从这个链表的这个节点被取走而剩下的1个分区就是内存碎片，会留在空闲链表中。

所以页面大小应该适中，过大难以分配，过小则内存碎片会很多。
页面大小通常为 512B~8K

通过页式管理，可以将进程的每个页面放到内存的字块中。

所以平时说的,系统给进程分配内存,其实具体就是为进程定义一个逻辑空间并将空间中页映射到物理内存块中。


但是怎么知道进程的页面存储在哪一个字块中？

页表
页表记录进程逻辑空间和物理空间的映射
一个进程有一个页表，该页表记录着这个进程中所有的页。

页表一个类似map的结构
页号      字块 
1           1  
2           3
3           5
4           10
5           12


页号相当于字块
页内偏移相当于字块中字的偏移（字的位置）

页地址 = 页号+页内偏移

页是逻辑空间是虚拟的，而字块是内存中的物理空间是真实的载体。

页式存储管理的问题
在一个32位系统，最多只有4G的内存上限，假设一个页的大小是4KB，那么页的总数上限=4G/4K=1M，所以有1M这么多个页（字块）。那么每个进程的页表中的页就有1M个。
如果一个页表中记录一个页表项要1byte，那么每个进程的页表要占1M*1byte=1M的内存。

注意这里不是说一个进程要占1M内存，而是一个进程的页表要占1M内存。


如果有一段连续的逻辑分布在多个页面，将大大降低执行效率



段式存储管理

相比于页式存储管理，页式是将进程的逻辑空间等分成若干段
而段式存储管理是将进程的逻辑空间不等分的划分为若干段

段的长度由连续逻辑的长度决定。一段连续的逻辑会存储在一个段中，而页式存储管理则是一段连续的逻辑会分散在多个页中。

段式存储管理也有一个段表记录每个段的信息。段表包括三个内容：
段号  基址  段长
1     10k    30k
2     40k    10k
3     50k    40k 
...

因为段的空间是不等的，所以除了要记录段长，还要记录每一段的起始位置，也就是基址，当然这个基址不是指这个段的地址。

段地址 = 段号+段内偏移


对比段式存储和页式存储：
共同点：段式存储和页式存储都离散的管理了进程的逻辑空间（都将进程空间分成若干块）

不同点：
页是物理单位，段式逻辑单位
分页是为了合理利用空间，分段是满足用户需求
页大小由硬件固定，段长度可动态变化
页表信息是一维的，段表信息是二维的

分页可以有效提高内存利用率（虽然会产生内存碎片）
分段可以更好的满足用户需求


段页式存储管理
先将逻辑空间按段式管理分成若干段
再把段内空间按页式管理分为若干页

段页地址 = 段号+段内页号+页地址


页式存储，段式存储和段页式存储都是为了管理进程中的逻辑空间，而将逻辑空间分割并映射到内存中。



========================================================

内存管理

问题：一个游戏有十几个G，但是计算机内存只有4G，请问这个游戏是怎么跑起来的？

虚拟内存 
为什么要有虚拟内存？因为：
1.有些进程实际需要的内存很大，超过了物理内存的容量
2.多道程序设计使得每个进程可用物理内存更加稀缺（意思是，由于多个进程可以并发或者并行，每个进程都需要内存，这样物理内存就更紧缺了）
3.不可能无限制的在电脑上增加物理内存

也就是说，大程序（消耗很大内存的程序）的运行以及多进程并发会使得物理内存总是不够这些进程运行所需的内存


虚拟内存是操作系统内存管理的关键技术
使得多道程序运行和大程序运行成为现实

那么虚拟内存是怎么实现“在物理内存小于所有进程所需内存的情况下”还能让进程们正常运行呢？
是通过将程序所使用的内存划分，将每个进程部分暂时不使用的内存放到辅存（磁盘）中。如果是进程正在使用的内存那么这部分内存不能放在磁盘中，这部分使用的内存还是消耗的物理内存的。



程序的局部性原理
局部性原理是指CPU访问存储器时，无论是存取指令还是村塾数据，所访问的存储单元都趋于聚集在一个较小的连续空间。


局部性原理是虚拟内存实现的重要原因。

程序运行的时候，无需将进程的所有逻辑空间都装入内存，而只装部分即可（进程中的一些页映射到内存，一些页映射到了辅存）
如果访问页（页式管理中的页）不在内存里，则发出却页中断，发起页面置换（简单的说是从辅存中获取进程暂存到辅存的数据，并将数据写入内存）
从用户层面看，程序拥有很大空间，就是因为虚拟内存

虚拟内存实际是对物理内存的补充，速度接近于内存，成本接近于辅存。


虚拟内存置换算法（即辅存和内存交换数据的算法）
FIFO    先进先出算法
LFU     最不经常使用算法
LRU     最近最少使用算法

这里和之前说的，主存和高速缓存的置换算法基本一致，这里不再赘述。

接下来对比主存-辅存置换与高速缓存-主存置换：

回顾一下，高速缓存和主存什么情况下才会置换或者说高速缓存什么时候要写入主存
当CPU处理程序时生成的数据在缓存中放不下时缓存中的数据就会写入主存。当CPU要获取的数据不在高速缓存中时，高速缓存就会从主存获取再供CPU使用。

主存和辅存置换的时机则在于当出现主存缺页的时候，主存就会读取辅存的内容。

两者的不同点：
Cache-主存的置换是为了解决速度不匹配的问题
主存-辅存的置换是为了解决容量问题，因为物理内存远远小于程序运行所需内存。

两者相同点：
置换的算法相同


总结：
物理内存 = 计算机实际的内存空间
虚拟内存 = 物理内存+辅存

==============================================
Linux的存储管理

Buddy内存管理算法
我们知道，内存中的空闲内存是一串连续的小空间隔着一些已用的空间又连着一串连续的小空间。在链表中表现为连续的空闲分区作为一个节点。
而进程使用内存的时候，也是使用连续的内存分区，比如某个进程要用到10个分区，它不会再内存中东取一块西取一块，而是在节点中获取连续的10个分区。但即便这样，这个节点也会出现内存碎片，例如这个节点有12个连续空闲分区，被进程使用10个分区就会剩余2个空闲分区，这两个空闲分区就是内存碎片。

内存碎片造成的问题是：一些需要使用稍微较多的内存的程序会用不上这些内存碎片，比如进程都是用8块10块空闲分区，但是作为空闲链表的某个节点只有2个分区，那么这些内存就不会被这些进程用到导致内存浪费。

上面所说的是内存页外碎片


页外碎片和页内碎片
内部碎片是已经分配给程序（能明确之处属于哪个进程）的内存空间大于这个进程所需的内存空间，不能被利用的内存空间就是内部碎片。
例如：程序要用10.3个页的内存，但是内存会分配11个页给这个程序，因为内存是按整页整页的算的

外部碎片是还没有分配，但由于太小而无法分配给申请内存空间的进程的内存空闲块。


该算法主要是为了解决内存外碎片的问题。

具体如下：
系统会生成11个链表，每一个链表分别放着节点大小不同的节点。节点最小的链表中每个节点只有1个连续页，节点最大的链表中每个节点有1024个连续页，每条链表有多个节点，一页大概有4k。
11条链表链表分别包含节点大小为1，2，4，8，16，32，64，128，256，512和1024个连续页的页框块。
1024个连续页链表的一个节点约为4M

例如：每个节点只有1个页的链表,假如*是一页，-代表节点的连接（指针）
*-*-....-*

每个节点有4个连续页的链表
****-****-****-...-****

buddy算法中，分配内存给进程时，遵循2的幂次方大小的原则
例如进程要申请使用100k的内存。那么系统会分配128k给进程。

现在假如某进程要233个页的内存，于是系统会分配256页的内存给它。
所以，系统会先到256连续页的那条链表去找
a.如果这条链表不为空，就会从链表中取出一个节点（256个页）给进程。

b.如果这条链表为空，就会到512连续页的链表去找，如果512链表不为空，系统会取下里面的一个节点，并均分为两个256连续页的大页块。一个分配给应用，另外一个移到256个页框的链表中。如果512个页的链表中仍没有空闲块，继续向1024个页的链表查找，如果仍然没有，则返回错误。

内存在回收时，会先将256个页放回256的链表中，如果这256个页能在链表中找到另一个地址连续的256个页，就会合并为512个连续页并放到512那个链表，如果还能找到连续的就再合并，并发到1024的链表。

这个算法是基于计算机处理二进制的优势具有极高效率

这个算法解决了内存外碎片的问题，一个节点不会被用的只剩一点点残渣，而是会把分割的节点往下级链表中放。

但是会存在页内碎片，例如上面说到的，如果进程要用到100k内存，系统会分配128k，剩下的28k在进程中是没有被用到的

相当于将页外碎片问题转移为页内碎片问题，尽管如此，buddy算法依然大大提高了内存使用的效率


Linux的交换空间（Swap）
Swap是磁盘的一个分区。
当Linux的物理内存不足时，会将一些内存交换到swap空间
swap是安装系统时配置的

可以用top命令看到Swap的信息。

虽然Swap分区可以分担物理内存的压力，但是不推荐使用，因为swap空间还是在磁盘中，所以速度会比较慢。如果频繁使用Swap就会导致Linux会运行的很慢。

swap的作用：
冷启动内存依赖：一些程序在开机的时候会运行，开机后就不怎么运行了，所以开机完毕后这些程序的数据会从内存写到swap，使的内存得到释放。
系统睡眠依赖：当系统睡眠时（不是关机，是睡眠），会将内存数据放到swap，等下次系统启动时会从swap加载到内存。
大进程空间依赖：就是进程需要很多内存，但是该进程有很多内存是暂时不使用的，这部分的内存会放到swap中暂存。


Swap和虚拟内存很像，但不是一回事：
swap和虚拟内存都存在于磁盘
都会和主存发生置换

但：
swap是操作系统概念，虚拟内存是进程概念
swap解决系统物理内存不足问题，虚拟内存解决进程物理内存不足问题


=========================================

操作系统的文件管理

文件的逻辑结构

文件可以分为：
有结构文件：文本，文档，媒体文件（图片，音频，视频）

无结构文件：二进制文件，链接库

有结构的文件的文件内容由定长记录和可变长记录组成
定长记录存着文件格式，文件描述等结构化的数据项
可变长记录存着文件具体内容

无结构文件又称为流式文件，内容长度以字节为单位
exe,dll,so 文件都是流式文件




顺序文件
是按照顺序存在存储介质中的文件
顺序文件是所有逻辑文件当中存储效率最高的
但是如果想再顺序文件的中间加内容或者修改删除是非常没有效率的
可变长文件不适合使用顺序文件格式存储


索引文件
索引文件是为了解决可变长文件存储而发明的文件格式
索引文件比顺序文件多一个索引表来完成存储的操作，索引表包括两个字段，key和value，一个key指向一段文件内容（索引文件会将所有的文件内容分割为多段）。


辅存的空间分配

分配方式：连续分配，链接分配，索引分配

一个文件的存储需要存到磁盘的多个扇区（或者说盘块）。

连续分配是为一个文件分配多个扇区，而这多个扇区是连续的。
例如有1~10000个扇区，某一个文件被分配到的是1~6号扇区

连续分配优劣：顺序读取文件很快；对存储要求高，要求满足容量的空闲连续存储空间（例如某个文件要分配1000个扇区，但是没有1000个连在一起的扇区，只有1000个离散的扇区）


链接分配是将文件存在离散的盘块，但是要额外的空间存文件的盘块链接顺序

链接分配又包括显式链接 隐式链接

隐式分配
隐式分配的下一个“链接指向”是存在当前盘块中。
例如，某个文件的内容映射到了5个扇区，按顺序分别是第2,9,7,18,16号盘块。2号盘块存着一个链接指向9号，9号存着链接指向7号以此类推。
根据链接可以找到下一部分文件内容存在哪个盘块中。

隐式分配适合顺序访问，随机访问效率很低（例如我要访问第16号盘块的内容要先2号->9号->7号->18号->16号，无论要找哪个盘块，我们都要从第一个盘块开始找）

显式分配
显式链接分配会单独将链接的指向放到一个表中，这个表存放着一个磁盘所有文件的盘块和链接指向。这个表叫做FAT表，即FAT文件系统
例如，某个文件被分配到了5个扇区，按顺序分别是第2,9,7,18,16号盘块。
FAT表为：

物理块     指向下一盘块的链接
...         ...
2           9
...         ...
9           7
...         ...

FAT不支持高效直接存储访问（因为FAT记录的条数很多，磁盘越大，FAT表的记录数就越多）。
当读取某一个文件的内容时，为了获取该文件的所在盘块，要检索整张FAT表，一个是慢，一个是要将整个FAT表加载到内存，会占用内存空间。


索引分配
会将一个文件所占有的盘块的索引单独放到一个盘块（索引块）中。当访问这个文件时，只需获取这个放索引的盘块（索引块）并将其内容加载到内存就能读取到任意一个存文件内容的盘块。

例如，某个文件被分配了5个盘块，按顺序分别是第2,9,7,18,16号盘块。将2,9,7,18,16这几个索引放到第12号盘块存放（存放的可能是一张索引表，类似与之前的FAT表，记录这盘块和下一盘块的链接）。

读取该文件的9号内容时，就会先读取12号盘块，获取索引表，从表中获取9号盘块链接，再去9号盘块取内容

每一个文件都有一个索引块

索引分配是现在的主流磁盘存储空间分配方式


辅存的空间管理
空闲表，空闲链表，位示图

空闲表：
序号      第一个空闲盘块号    空闲盘块数
1           2                   4       #2号~5号是连续的空闲盘块
2           9                   1      #只有9号是空闲的 
3           11                  32  
4           56                  20 

空闲链表： 
一个链表节点存着空闲盘块号和空闲盘块的数目

和空闲内存链表优点类似


位示图
记录每个盘块是否被使用（0/1来标记）



目录管理
目录是使用树型结构来管理的。

由于是树型结构，所以任何一个文件或者目录都有唯一的路径



Linux的重要目录
/bin    命令文件目录
/etc    配置文件目录
/home   家目录
/usr    系统应用目录 /usr/local
/proc   系统内存的隐射，存放内存，进程和CPU的信息（Linux中一切皆文件所以进程也是命令）
/dev     设备目录
/boot   开机引导目录
/root    超级管理员家目录

Linux的文件类型：
普通文件(-)
目录文件(d)
软连接(l)
设备文件(b/c)
套接字(s)
FIFO(p)


Linux的文件系统
文件系统有三种：FAT、EXT2/3/4，NTFS

FAT：用一张表保存所有盘块信息

NTFS：是Windows7,8,10的文件系统，是FAT的改进

EXT：又称扩展文件系统，一般是Linux常用的文件系统

Windows可以使用FAT,NTFS，但是无法使用EXT文件系统。
Linux则三个都可以使用。

如果讲一个EXT格式的U盘插入Windows的计算机中，计算机是无法识别的。

一个计算机可以接入多块磁盘，每一块磁盘都有自己的文件系统。比如你Linux系统机器里有两块磁盘，再接入一个U盘，磁盘1可以是NTFS系统，磁盘2是EXT系统，U盘可以是FAT32系统

EXT文件系统

ext文件系统下，文件系统会把磁盘逻辑上分为一个启动扇区（boot sector）和多个块组(block group)

启动扇区用于安装开机管理程序
块组用于存放文件系统的数据

每一个块组都包含以下内容：superblock/文件系统描述/inode bitmap/block bitmap/inode table/data block 


inode table （索引节点）
存放文件的iNode的地方
每一个文件或者目录都有一个inode
inode就是索引节点
所以ext文件系统是使用索引分配的方式给文件分配磁盘空间的。

inode（索引节点）具体存了：文件编号（唯一id），文件类型，文件权限，文件物理地址，文件长度，文件连接计数，文件状态，访问计数（当前那几个进程访问了这个文件），文件存取时间，链接指针，等等

文件名不是存放在inode节点上的，而是存放在目录的inode节点中。目的是，列出目录内所有文件的时无需加载文件的inode


inode bitmap（inode的位示图）
用于记录已分配的inode和未分配的inode（0/1标记）


data block
存放文件内容的地方。就是我们上面所说的盘块

block bitmap 
记录block的分配和未分配的情况


PS：块组不是存放一个文件的内容的，而是这很多inode和block的内容和信息的容器。
一个块组里面包含了很多block(盘块)和很多的inode（索引节点）。一个文件会使用一个inode记录文件的相关信息，使用多个block存储文件内容。


接下来具体看一下块组里面放了些什么：

#执行 
df -T

#得到
Filesystem     Type     1K-blocks     Used Available Use% Mounted on
/dev/vda1      ext4      51473888 18996804  29839336  39% /
devtmpfs       devtmpfs    930668        0    930668   0% /dev
tmpfs          tmpfs       941444       24    941420   1% /dev/shm
tmpfs          tmpfs       941444      752    940692   1% /run
tmpfs          tmpfs       941444        0    941444   0% /sys/fs/cgroup
tmpfs          tmpfs       188292        0    188292   0% /run/user/0


# 可以看到，系统将磁盘 /dev/vda1 挂载到了 根目录/ 上面。
# /dev/vda1这个磁盘是ext4的文件系统


# 执行 
dumpe2fs /dev/vda1  > vda1.log      # 查看/dev/vda1磁盘的信息


# 下面是磁盘信息的部分内容
Filesystem OS type:       Linux
Inode count:              3276800       # inode节点的总数
Block count:              13106944      # 盘块的总数，一个文件可能会被分配多个盘块，所以block数量比inode多
Reserved block count:     655341    
Free blocks:              11692441      # 空闲盘块数
Free inodes:              3168592       # 空闲inode数
First block:              0
Block size:               4096          # 每个盘块可存4096bit的内容(0.5k)
Fragment size:            4096
Group descriptor size:    64
Reserved GDT blocks:      1017
Blocks per group:         32768         # 一个块组包含多少盘块    
Fragments per group:      32768
Inodes per group:         8192          # 一个块组包含多少inode
Inode blocks per group:   512
Inode size:               256           # 一个inode的大小为256字节

Group 0: (Blocks 0-32767) [ITABLE_ZEROED]       # 第一个块组的详细信息，它存放着0号-32767号盘块
  Checksum 0x77e2, unused inodes 0
  Primary superblock at 0, Group descriptors at 1-7
  Reserved GDT blocks at 8-1024
  Block bitmap at 1025 (+1025), Inode bitmap at 1041 (+1041)
  Inode table at 1057-1568 (+1057)
  20512 free blocks, 1 free inodes, 1275 directories
  Free blocks: 10597, 10793, 12190, 12192, 12208, 12250, 12262-32767
  Free inodes: 8075
  
Group 1: (Blocks 32768-65535) [ITABLE_ZEROED]
  Checksum 0xc009, unused inodes 2235
  Backup superblock at 32768, Group descriptors at 32769-32775
  Reserved GDT blocks at 32776-33792
  Block bitmap at 1026 (bg #0 + 1026), Inode bitmap at 1042 (bg #0 + 1042)
  Inode table at 1569-2080 (bg #0 + 1569)
  6041 free blocks, 2901 free inodes, 1424 directories, 2235 unused inodes
  Free blocks: 34464-34559, 34685, 34688-34815, 35394, 35396-35399, 35408-35420, 35424-35425, 35556, 35571-35572, 35574-35578, 35580-35581, 35583-35700, 35702-35703, 35705-35710, 35715, 35724-35738, 35741, 35746, 35750, 35752-35765, 35769-36162, 36171-36181, 36184, 36187-36193, 36195-36210, 36212-36215, 36217-36222, 36224-36225, 36227-36228, 36230-36241, 36243-36254, 36267-36556, 36560-36714, 36719, 36721-36750, 36752-36840, 36846-37059, 37064-37254, 37256-37261, 37265-37272, 37274-37735, 37737-37743, 37745-37750, 37752-37774, 37776-37778, 37780-37989, 37991-38030, 38032-38066, 38068-38084, 38101, 38103-38109, 38111, 38115-38283, 38285-38295, 38297-38301, 38304-38319, 38321-38322, 38324-38337, 38345-38359, 38362-38437, 38441-38458, 38460, 38462-38495, 38498-38888, 38892-38910, 38912-39412, 39414-39423, 39513-39935, 40978, 40987-40990, 40992, 40995, 40998-40999, 41006, 41008-41469, 41471-41619, 41621, 41624-41654, 41656-41658, 41660-41661, 41663-41665, 41667-42289, 42304-42495, 45432-45439, 47188-47222, 62223-62233, 62258-62273, 63050-63104, 63490-63532, 65237-65251
  Free inodes: 13483, 13485-16384

.....


# 查看随意的一个文件的inode和block信息
# 执行
stat vda1.log

#得到
  File: ‘vda1.log’
  Size: 685008          Blocks: 1344       IO Block: 4096   regular file
Device: fd01h/64769d    Inode: 465547      Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2020-03-14 15:02:46.669280468 +0800
Modify: 2020-03-14 15:02:46.753280598 +0800
Change: 2020-03-14 15:02:46.753280598 +0800


文件大小为 685kb , 占用了1344个块，索引号为465547
索引号可以说是文件的唯一标识

修改文件名不会影响索引号





Linux的设备管理

广义的IO设备
对CPU而言，凡是对CPU进行数据输入的都是输入设备，凡是负责CPU数据输出的设备都是输出设备

例如，CPU进行运算后将数据写入内存或者写入高速缓存，那么高速缓存或者内存就是IO设备中的输出设备

CPU对高速缓存或者内存进行读写就是IO操作。

按使用特性，可以将IO设备分为
存储设备：U盘，磁盘，内存
交互IO设备：鼠标，键盘，显示器

按信息交换的单位可分为
块设备：磁盘，SD卡
字符设备：打印机，shell终端

块设备是以块（block）为单位进行交互的设备
字符设备是以字符为单位进行交互的

因为一个block包含很多字节，所以块设备的交互速度比字符设备快很多

按照传输速率分类
1）低速设备
传输速率为每秒钟几个字节至数百个字节的一类设备。属于低速设备的典型设备有键盘、鼠标器、语音的输出和输出等。
2）中速设备
这是指其传输速率在每秒钟数千个字节至数万个字节的一类设备，典型的中速设备有行式打印机、激光打印机等。
3）高速设备
这是指其传输速率在数百个千字节至千兆字节的一类设备。典型的高速设备有磁带机、磁盘机、光盘机等


按设备的共享属性分类
这种分类方式可以将IO设备分为如下三类：
1）独占设备
这里是指在一段时间内只允许一个用户访问的设备，即临界资源。因而，对多个并发进程而言，应当互斥地访问这类设备。系统一旦把这类设备分配给某进程后，便由该进程独占，直到释放。
2）共享设备
这是指一段时间内允许多个进程同时访问的设备。当然，对于每一时刻而言，该类设备仍然只允许一个进程访问（并发而不是并行）。显然，共享设备必须是可寻址和可随机访问的设备。典型的共享设备是磁盘。
3）虚拟设备
这是指通过虚拟技术将一台独占设备变换为若干逻辑设备，供若干个用户（进程）同时使用。



IO设备的缓冲区

我们之前的说的CPU和IO设备的速率不匹配，除了可以通过添加高速缓存来解决之外，IO设备的缓冲区也能做到。

IO设备的缓冲区可以：
减少CPU处理IO请求的频率（这里不是说CPU进行IO操作，而是说CPU发送IO请求，CPU是不进行IO操作的。进程提出IO请求时，CPU将IO请求发给IO设备，让IO设备处理请求）
提高CPU和IO设备之间的并行性

两个例子：
1.一个程序和一个IO设备进行了四次交互，比如一个php脚本中对一个文件写入了四次（调用了四次fwrite()）
那么它不是每调用一次fwrite()，就往文件里面写一次。
而是会将四次写入的内容放到缓冲区再一次性的写入磁盘中。（前提是四次写入的内容的大小没有超过缓冲区的大小）
这样的话，原本CPU要对磁盘发出4次IO操作的请求，现在变成只有1次请求。

PS：
专用缓冲区只使用于特定的IO进程
当这样的IO进程比较多的时候，内存消耗也很大（缓冲区本质是内存空间）
所以操作系统划分出可供多个进程使用的公共缓冲区，叫做缓冲池

一个缓冲池有多个缓冲区，当进程需要进行和IO设备交互的时候，就会从缓冲池取出一个合适大小的缓冲区使用。用完以后（比如关闭文件句柄或者进程运行结束）会归还这个缓冲区给缓冲池



SPOOLing技术
是关于慢速的字符设备如何与计算机主机交换信息的技术
利用高速共享设备（磁盘）将低速的独享设备模拟为高速的共享设备
逻辑上为每一个用户（或者说进程）都分配了一台独立的高速独享设备

所以SPOOLing技术是一种虚拟设备技术

举一个例子：
有3个进程都要使用打印机（打印机是输出设备，进程要将数据输出到打印机上），由于他是独享设备，所以每一个进程要使用完毕这个设备才能释放这个设备给其他进程用。而且他的速度比较慢，所以其他进程要等很久才能用到这个打印机。

如果使用spooling技术，则不会直接把打印机分配个某一个进程。而是将3个进程的数据输出到磁盘的文件中，因为磁盘是高速设备，而且是共享设备，所以3个进程可以同时（并发不是并行）写入磁盘放到文件中而且写入速度很快。然后3个进程就执行结束了。

这些文件会放到一个队列中，spooling进程会调用打印机一次次的将队列中的文件的内容输出。

spooling技术把同步调用低速设备改为异步调用（进程只要输出完自己的数据到磁盘就完事，不用管数据有没有输出到打印机）

那么这个队列叫做输出井或者输入井。spolling负责输出井和低速设备的调度
逻辑上，进程是直接和高速设备交互而不是和低速设备交互，减少了进程等待的时间，也加快的传输速度。