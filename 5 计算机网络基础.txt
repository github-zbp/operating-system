计算机网络基础概述

网络层级结构设计的基本原则
计算机网络是使用分层来实现的。

分层设计的原则：
1.各层之间是相互独立的，这一层不需要知道下一层或者上一层是怎么实现的。即层与层之间耦合度是非常低的。

2.各层之间完全解耦

3. 每一层要有足够的灵活性


OSI七层模型

由上到下是：
应用层（为计算机用户提供接口和服务，应用层是直接面向用户的）
表示层（数据处理，如编码解码，加密解密）
会话层（管理(建立，维护，重连)）通信会话
传输层（管理端到端的通信连接）
网络层（数据路由(决定数据在网络的路径)）
数据链路层（管理相邻节点之间的数据通信）
物理层（数据通信的光电物理特性）

每一层都分别完成一个特定任务。

OSI最终没有成为广为使用的标准模型



TCP/IP四层模型

由上到下是：
应用层（相当于OSI模型中的应用层，表示层，会话层）
传输层 
网络层 
网络接口层（相当于OSI模型中的数据链路层和物理层）

TCP/IP四层模型才是现在广为使用的模型


之后的学习都是围绕着TCP/IP模型学习的





现代互联网的网络拓扑

Q:终端机器（如电脑，手机）是怎么连到另一台终端的

以家庭为例
终端通过有线或者无线的方式和路由器连接。
路由器连接当地的网关，一个网关可能和一个或多个路由器连接
网关连接较近的地区ISP

以企业为例
终端通过有线或者无线的方式和路由器连接。
路由器连接当地的网关，企业可能有多个路由器和多个网关，这些网关组成内部网关。还有一个统一网关，这个统一网关会收敛所有内部网关的连接，提供一个接口和地区ISP连接


多个地区ISP会连接到主干ISP，多个主干ISP通过国际路由器进行连接。


两台机器要经过多少路由器或者网关才能连接到要看两台机器的位置。
例如机器 A和B 隔得很近，甚至就是局域网中的两台机器，A只需通过一台路由器就能连接到B从而和B通信
如果 A和B 在中国深圳和美国纽约，那么就要经过路由器，中国的网关，国内地区ISP，中国主干ISP，国际路由器，美国的ISP，美国的网关，路由器，最后到B


以树状结构表示的话：
主干ISP在顶层，往下分支是地区ISP，再往下分支是公司，校园，家庭这样的边缘部分


PS：ISP（Internet Serveice Provider）网络服务提供商。如联通，电信和移动。
其中 地区ISP是指 广东联通，北京联通，湖南联通等
     主干ISP指 中国联通，中国电信
按照地区范围可以将ISP分为大大小小的ISP。

国家与国家之间通信是通过国家之间的ISP连接做到的。




客户-服务器模式(C/S模式)
这也是我们最熟悉的模式。即客户端发送请求给服务器，服务器返回响应。客户端和服务端通过互联网连接起来(路由器，网关，ISP等)

对等连接模式(P2P模式)
通过互联网连接的两台主机不分谁是客户端谁是服务端。


==============================

计算机网络的性能指标

网络常用单位是 bps ,即 bit/s 每秒多少字节

时延：
网络中的时延包括四个：
1. 发送时延
发送时延 = 数据长度(bit)/发送速率(bit/s)
其中发送速率是指计算机网卡带宽

例如你要发送一个 100M 的视频。
你的带宽是1000Mbps

此时发送时延= 100*8/1000=0.8s

2. 传播时延
传播时延 = 传输路径距离/传播速率(bit/s)
其中发送速率不是由网卡，带宽决定的。而是由传输介质决定(光纤还是铜线)
传输距离，相同介质下，从北京传到深圳肯定比北京传到美国快

3. 排队时延

指数据包在网络设备中等待被处理的时间。因为数据从终端发送到路由器或者网关的时候，路由器不是马上处理你这个数据包，它会处理很多数据包，所以你这个数据包可能要排队等待，才会被处理，然后再发往下一个设备（如网关）


4.处理时延

处理数据包化的时间


总时延等于上述四个时延之和


往返时间（RTT）
RTT是数据报文在端到端通信中来回一次的时间。
通常可以通过ping查看RTT

RTT的长短也是取决于你的机器和目标机器的距离。
如果你在深圳，使用的是深圳的网络。此时你ping广州的一个IP会比ping一个北京的IP锁所花的RTT长



时延，RTT都是衡量网络性能的重要指标


===================================

下面将正式学习 TCP/IP四层模型 的每一层

A 物理层+数据链路层

物理层 
作用：负责连接不同的物理设备，传输比特流（高低电平）

信道的基本概念：
信道是往一个方向传送信息的媒体
机器和机器连接的一条通信电路中包括一个接受信道和发送信道

信道包括：
单工通信信道：只能一个方向通信，没有反方向反馈的信道。例如有线电视，只能接受信号，不能发送信号。
半双工通信信道：双方都可以发送和接受消息，但是不能双方同时发送或同时接收。
全双工通信信道：双方都可以发送和接受消息，双方能同时发送或同时接收。


分用-复用技术
我们知道机器与机器间它们的底层是通过信道来进行通信的。
但是现实中有很多台机器，不可能每两台机器之间都有一条信道连接，这样线路会很复杂

因此提出了分用和复用的技术。
通信双方的机器共同连接分用器和复用器，分用器和复用器用一条信道进行发送和接受消息，就可以大大减少信道。
但是如果通信双方的多台计算机频繁通信就会造成拥塞，因为只有一条信道。




数据链路层
作用： 
1.将数据封装成帧
帧是数据链路层数据的基本单位
发送端经过数据链路层时会在数据前后添加特定的标记形成“帧”
接收端经过数据链路层时会识别出帧

2.透明传输

3.差错检测
物理层只管传输比特流，无法检查数据在传输过程中是否有出错
数据链路层可以检测出数据从出发传到目的端过程中是否有出错
数据差错检测是在目的端的数据链路层中进行的

数据链路层是如何进行差错检测？
a.奇偶检验码
b.循环冗余校验码CRC

接收端机器的数据链路层只进行数据的检测，但不会进行错误纠正，而是将错误的数据直接抛弃。


MTU （最大传输单元）

数据链路层的数据帧不能是无限大的（数据帧是指数据链路层中数据头部的帧的长度+数据尾部的帧的长度+数据本身的长度）

数据帧过大或者过小都会影响传输效率

数据帧可以认为是要传输的数据的大小，而MTU是线路每次能传输的最大大小

如果数据帧大小超过MTU就要分多次传输。

以太网的MTU一般为1500字节


路径MTU：
不同路径的MTU不同，例如从机器A到机器B，要经过：
A --- 路由器1 --- 网关1 --- 网关2 --- 路由器2 --- B

经过5个路径

每个路径的MTU分别为 1500 1492 4464 1500 2000

此时整个线路的MTU（即路径MTU）由链路中MTU的最小值决定。
所以在这里的路径MTU是1492

PS：像电脑，手机这样的终端是七层都具备，但是路由器只有两层即数据链路层和物理层



以太网协议
以太网协议是数据链路层的一种协议

例子：
A,B,C三台机器，他们通过一个路由器就能够相互连接和通信。

A发送数据给B，是如何做到数据发给B而不是发给C的呢？


首先介绍一下
MAC地址（又称物理地址，硬件地址）
每一个设备都有唯一的MAC地址，MAC地址共有48位，一般使用十六进制表示，形如：50-E0-85-DF-5E-99 这个样子
在自己的电脑中可以通过 ipconfig /all 查看

PS：MAC地址不是指电脑这台机器的地址，而是这台电脑中的网卡这个硬件设备的物理地址。MAC地址不可改变，当这块网卡被生产下来后其MAC地址就已经被决定好了。

以太网（Ethenet）是一种广泛使用的局域网技术，也是一种应用于数据链路层的协议。
使用以太网可以完成相邻设备的数据帧传输（就是完成相邻设备的数据传输，数据帧就是数据+数据首位的帧而已）

以太网协议中的数据形式如下：
        目的地址    原地址     类型      帧数据     CRC
长度      6字节     6字节      2字节    46~1500字节   4 

数据的前12个字节分别记录了目的端的MAC地址和发送端的MAC地址。
帧数据才是真正的数据内容


MAC地址表
这个地址表有两个字段：MAC地址和硬件接口,呈映射关系

MAC地址                   硬件接口
50-E0-85-DF-5E-99           接口1
51-E0-85-DF-5E-9C           接口2
43-EE-FA-82-4C-32           接口3
...                         ...


MAC地址表是存在路由器当中的 。
路由器会记录每一个连接它的设备（手机，电脑，或者其他路由器）的MAC地址和这个设备的接口。只要一个设备连接了这个路由器，路由器就会在MAC地址表中添加这个设备的MAC地址信息和硬件接口信息。


现在回到刚刚的问题：
A,B,C三台机器，他们连接着一个路由器，A发送数据给B，是如何做到数据发给B而不是发给C的呢？

过程如下：
A通过网卡发出数据包
数据包到达路由器，路由器取出数据的前六个字节得到目的机器B的MAC地址
路由器根据MAC地址表找到目的机器B的网络接口
数据就发送到了B


现在有一个稍微复杂的网络
A，D和F连接着路由器E，A和D是电脑，F是另一个路由器。
B和C两台电脑连接着路由器F

以太网协议只能让A节点通过E找到D和F，却无法直接找到C
这就是之前所说的以太网协议只能做到数据在相邻物理节点间的传输

网络层可以解决这个问题。



================================================

网络层 

网络层之IP协议

1.虚拟互联网络
实际的计算机网络是错综复杂的
物理设备通过使用IP协议，屏蔽了物理网络之间的差异
当网络中的主机使用IP协议连接时，则无需关注网络细节

上面这三句话可能比较抽象。举个例子，
机器A想发数据给机器B，A和B之间不只有一条路相通。
比如 A是深圳机器，B是北京机器
A要发数据包给B，这个数据可以经过路由器M到达网关K，网关K再转发给上海联通，再转发给网关J，网关J再转发给路由器N，最后到达机器B。这是一条路。

也可以走另一条路
A要发数据包给B，这个数据可以经过路由器M到达一个中型网络，再转发到武汉联通的一个路由，再转发给网关X，再转发给路由器N，最后到达机器B。

类似这样的能让A的数据包到达B的路太多，所以计算机网络在物理层面上是很复杂的。

而我们无需关心A到底是走哪条路到达B的，无需理会A的数据包通过什么途径到达B。所以我们不必理会这么复杂的物理网络线路和其中的传输细节。

我们只需将A和B之间的线路当做是一个虚拟的互连网络。我们无需理会这个虚拟互连网络内部的细节，只需要知道A能通过这个网络连向B即可。

网络层的IP协议就可以是的复杂的实际网络变为一个虚拟互连的网络。

总结：IP协议的作用就是给每一个机器分配一个唯一地址，从而将一个IP地址的数据发送到另外一个IP地址所代表的设备。也就是说IP协议的作用就是让信息从一个机器准确传给另一个机器，而不会传错给其他机器。

IP协议
我们知道每一个机器（电脑，手机，路由器等等）都有一个唯一的MAC地址。它用二进制表示是一个48位的地址

而IP地址用二进制表示是一个32位的地址，不过我们习惯用点分十进制来表示：192.169.11.11 

MAC地址是数据链路层中的地址；而IP地址是网络层中的地址。二者都是唯一地址。

二者的区别：
MAC地址不会变；IP地址受网络环境影响会变。
例如：一块网卡从一个电脑拆下来换到另一个电脑，其MAC地址不会变。一个手机在家上网和在公司上网其IP地址会变


由于IP地址用二进制表示是32位，所以最多可以有 2^32=43亿 的IP地址



IP协议规定的数据形式
IP数据报 = IP首部+IP数据报中的数据

IP首部中包含但不限于以下内容：
源IP地址，目的IP地址，生存时间TTL，协议，首部校验和，片偏移，版本，首部长度，总长度。

版本：记录着IP协议的版本是IPv4还是IPv6。IP协议版本相同才可以通信。所以IPv4的IP地址无法和IPv6的IP地址通信

首部长度：记录着IP首部的长度。IP首部长度最大为60个字节。所以IP首部最多可以记录60字节的信息。

总长度:记录IP数据报（IP首部+IP数据）总长，总长最多为65535个字节。
我们知道网络的最大传输单元MTU一般都是1500个字节。如果IP协议中的数据有65535个字节，远远超过了MTU的大小。此时IP报文数据会被切割分批传输。

片偏移：记录着这个IP报文是不是分批传输，是的话该IP报文是第几片。

生存时间TTL：是IP报文的寿命。这个TTL不是时间，而是次数。
每经过一个设备，TTL会-1，当TTL=0，网络设备会丢弃这个报文。
TTL的作用是，当报文在网络中找不到终点时，防止报文无限次传输而不停消耗带宽。TTL可以保证让报文在有限的传输次数内找到目的机器或者被丢弃。

协议：记录着这个IP数据所携带的是什么协议的数据。如TCP，UDP，ICMP，IP（IP数据中还可以继续封装IP数据）等。

首部校验和：用于校验IP首部是否出错，如果出错则直接丢弃报文

源IP地址和目的IP地址就不必说，就是发送包的IP和包要到达的IP




IP协议的转发流程

逐跳（hop-by-hop）
A连接路由器X再连到B，A发送数据包给B的时候，是通过逐跳的方式转发的，数据包先跳到X，再跳到B。

路由表
路由表是工作在网络层的表（计算机和路由器都有路由表）。

路由表有两个字段：目的IP地址和下一跳的IP地址
目的IP地址      下一跳的IP地址
IP1                 IP4
IP2                 IP5
IP3                 IP6
......



IP协议的转发流程：
之前问过一个问题
A，D和F连接着路由器E，A和D是电脑，F是另一个路由器。
B和C两台电脑连接着路由器F。A如何将数据包发送给C？

仅从网络层来答：首先每一台机器都有自己的路由表
在A中，A指定目的IP为C的IP。
A在自己的路由表中，根据目的地址C的IP找到其下一跳的地址为E的IP

于是报文发到了路由器E。
在E的路由表中，根据目的地址C的IP找到其下一跳的地址为F。

于是报文发到了F。
在F同理，根据F的路由表和目的地址C的IP找到下一跳的地址为C的IP

最终报文达到C

上面的过程都是仅仅从网络层的层面解释的。因为路由表只在网络层存在。


从网络层+数据链路层来答：
我们知道在一个机器内，报文的加工是从上到下的。所以是现在网络层加工，后在数据链路层加工。

在机器A中：
网络层中，IP报文的IP首部的目的地址设为C的IP地址。查询路由表发现下一跳IP为E的IP（根据E的IP查询ARP缓存表得到E的MAC地址）
报文往A的下一层数据链路层传输，在数据链路层将目的MAC地址设为E的MAC地址，源MAC地址为A
报文再往A的下一层物理层传输，在物理层变成一堆二进制

数据根据下一跳地址传向路由器E

----

在接收数据的时候，报文是从下到上传的，所以

在机器E中：
E的物理层接收到电平往上一层数据链路层传，再将帧数据交给网络层
在网络层，根据C的IP查询路由表找到下一跳IP为F的ip

E把数据报文传到数据链路层，在报文中设置目的MAC地址为F,源MAC地址为E

向F发送 

-----

在机器F中，重复在机器E中的操作

在F中数据向上传到网络层后，查路由表找到下一跳为C
在数据链路层的报文中将目的MAC地址设为C的MAC地址
最后报文发到了C



在转发过程中，在数据帧（数据链路层中的报文形式）中每一跳的MAC地址都在发生变化，但是在IP数据报（网络层中的报文形式）中每一跳的IP地址始终不变。


======================================

ARP协议和RARP协议

ARP协议全称为 地址解析协议
其作用是将网络层的IP地址转化为数据链路层的MAC地址。

这也是为什么在上面的例子中，A可以知道E的MAC地址。虽然A没有MAC表。但是A有路由表，可以根据路由表找到下一跳E的IP，并根据E的IP地址转为MAC地址

网络层有一个ARP缓存表
存储着多个机器的IP地址和MAC地址的映射关系。例如E的IP对应着E的MAC就可以在ARP缓存表查到。

有两种情况：
ARP表缓存了某机器的IP地址和MAC地址的映射关系
ARP表没有缓存某机器的IP地址和MAC地址的映射关系

ARP缓存表的记录不是永久有效的，是有有效期的。因为机器IP地址会随网络环境而变。

ARP协议虽然是网络层的内容，但是ARP协议的报文是直接封装在数据链路层的数据帧当中的。


RARP是 逆地址解析协议
就是将MAC地址解析为IP地址


=====================================

IP地址的子网划分

IP地址如何分类
将IP地址分为网络号和主机号，网络号+主机号=32位长度

A类地址：前8位为网络号，后24位为主机号的地址
B类地址：前16位为网络号，后16位为主机号的地址
C类地址：前24位为网络号，后8位为主机号的地址

其中：
A类地址的第一位一定是0
B类地址的前两位一定是10
C类地址的前三位一定是110

没有为什么，这是规定好的。

但是从这里我们能知道A，B和C三类地址的最小和最大网络号的范围。
比如：A类地址的第一位一定为0，所以，A类地址的网络号用二进制表示其范围是：00000000~01111111，换成10进制是 0~127

B类地址的前两位一定是10，所以B类地址的网络号用二进制表示其范围是：10000000.00000000~10111111.11111111（B类地址的网络号有16位），换成10进制是 128.0~191.255

C类地址的前两位一定是110，所以C类地址的网络号用二进制表示其范围是：11000000.00000000.00000000~11011111.11111111.11111111（C类地址的网络号有24位），换成10进制是 192.0.0~223.255.255

所以如果问1.2.3.4是哪一类IP，就知道是A类IP，因为其网络号是1，在0~127中

156.42.33.233是B类IP，因为其网络号 156.42在 128.0~191.255 之间。


特殊的主机号：
主机号全0的是当前网络断，不可分配为特定主机
主机号全1的是广播地址，用于向当前网络段所有主机发消息的


特殊的网络号
A类地址的网络段为0,127的都是特殊网络
B类地址网络段为128.0的是特殊网络
C类地址网络段为192.0.0是特殊网络
这几个网络段都是不可用的

所以A，B，C的最小网络号是1,128.1和192.0.1
    A，B，C的最大网络号是127,191.255和223.255.255 

    A，B，C的IP范围是：1.0.0.1~127.255.255.254，128.1.0.1~191.255.255.254，192.0.1.1~223.255.255.254 
    
    判断IP地址是哪一类只需要看前八个位即可
    

回环地址(127.0.0.1)
这个地址不属于A,B,C类地址。它永远代表设备的本地虚拟接口，是永远不会宕掉的接口。  

具有相同网络号的IP我们称这些IP是同一个网段内的IP。
例如：C类IP的前24位都是网络号，只有最后8位是主机号。
所以 192.10.10.1~192.10.10.254的IP都是同一网段的IP，因为这些IP的网络号相同。192.10.10.6和192.10.11.106是不同网段的IP，因为前者的网络号是192.10.10 后者的网络号是192.10.11 

对于B类IP，它的前24位都是网络号， 所以像166.107.0.1~166.107.255.255 的IP都是属于一个网段内的IP，因为他们的网络号都是166.107

对于A类IP则以此类推

所以：C类IP的一个网段有2^8-2=256-2=254个IP
      B类IP的一个网段有2^16-2=256-2=65534个IP
      A类IP的一个网段有2^24-2=256-2=16777214个IP

以前一直以为 xxx.xxx.xxx.xxx 中前三个xxx相同才是同一网段。其实只有C类IP才是这样。B类和A类就不是这样。

同一网段的IP的通信更快


划分子网

一个问题：如果一个公司有100个员工，每人配备一个计算机，则公司应该申请哪类IP？
答：C类IP;因为C类IP的一个网段有254个IP>100，所以对于100个员工来说一个C类的网段的IP是够用的。

一个问题：如果一个公司有256个员工，每人配备一个计算机，则公司应该申请哪类IP？
答：B类IP;因为C类IP的一个网段不够。
可是B类IP的一个网段有65534个IP，远远大于256个IP，这样这个网段就有六万多个IP被浪费掉了。

可以通过划分子网的方式来解决这个问题。
可以将一个网段分为多个子网，那么计算机如何将一个网段划分为多个子网呢？
例如 193.10.10.0 这个网段，可以划分为
193.10.10.1~127 和 193.10.10.128~254 这两个子网
这样公司有100个员工，这个公司只需使用一个子网的IP就够了，就不用使用整个网段的IP数这么多。

一个网段可以分为多个子网，不一定只能划分为2个子网



子网掩码
子网掩码是一堆连续的1和0组成的32位的数字。子网掩码具有网络号位数个连续的1

例如：A类IP的网络号是前8位，所以A类IP的子网掩码有8个1和24个0，化为10进制为：255.0.0.0 
同理，B类IP的子网掩码是 255.255.0.0 ，C类IP的子网掩码是255.255.255.0 

每个子网都有自己的子网掩码。例如 193.10.10.1~127 和 193.10.10.128~254 这两个子网的子网掩码分别是 255.255.255.0和255.255.255.128

子网掩码的作用是快速查询一个IP是属于哪个子网的（通过将要查询的IP和子网的子网掩码进行一个&运算）



无分类编址CIDR
CIDR没有A,B,C类网络号和子网的概念
CIDR将网络前缀相同的IP地址称为一个“CIDR地址块”
网络前缀是任意位数的。

此时IP的组成就相当于：
IP=网络前缀+主机号

使用斜线记法来划分网络前缀
例如： 193.10.10.129/25 这表示前25位是网络前缀，后七位是主机号

11000001.00001010.00001010.10000001
-------- -------- -------- -

下划线部分都是网络前缀。
其中第25位为0和为1的就是两个不同的子网。
11000001.00001010.00001010.10000000=>193.10.10.128
11000001.00001010.00001010.01111111=>193.10.10.127
所以对于25位的网络前缀，xxx.xxx.xxx.0~127 就是一个子网，xxx.xxx.xxx.128~254 就是另一个子网

现在都是使用CIDR的方式来划分地址的。

现在回到最先的问题：如果一个公司有100个员工，每人配备一个计算机，则公司应该申请哪个网络段？
此时只需划分一个 以前25位为网络前缀的地址块给这个公司即可。
因为这个网络块的主机号有7位，主机数有2^7=128 个IP

拓展一下：
如果一个公司有200个员工，分为两个部门，每个部门100人，每人配备一个计算机，则公司应该申请哪个网络段？
此时只需划分一个 以前24位为网络前缀的地址块给这个公司，此时有2^8=256个IP可用。再将这个网络块划分为两个25位网络前缀的网络块给每个部门即可。
例如： 193.10.10.0/24 划分成两个25位网络前缀的网络块，这两个网络块分别是：193.10.10.0/25 和 193.10.10.128/25。

也就是说，总的地址块是：
193.10.10.1~254

两个小的地址块是：
193.10.10.1~193.10.10.127 和 193.10.10.128~193.10.10.254


===================================

网络地址转换技术(NAT技术)

ipv4的地址最多只有40多亿个，但是早期IP地址的不合理规划导致很多IP号浪费。

IP地址从另一个角度分可以分为
内网地址和外网地址
内网地址是内部机构使用的如家庭内，公司内，避免与外网地址重复
外网地址是全球范围使用的


内网地址有分为3类
10.0.0.0~10.255.255.255     支持千万数量级设备(A类内网地址)
172.16.0.0~172.31.255.255   支持百万数量级设备(B类内网地址)
192.168.0.0~192.168.255.255 支持万数量级设备(C类内网地址)


在家庭或者公司的设备（电脑和手机）使用的都是上述这3类IP范围内的内网地址而不是外网地址。
一个外网地址下有多个内网地址。

例如173.195.171.151这个外网地址下有192.168.0.0~192.168.255.255范围的内网地址。
173.195.171.152这个外网地址下也有192.168.0.0~192.168.255.255范围的内网地址。

那么这两个外网地址分别可以支持数万的设备，保证这些设备被分配到一个独立的内网地址。

例如，某一个家庭有一家三口，家里没有电脑，每个人有一个手机。这三个人分别使用 192.168.2.10,192.168.2.11,192.168.2.12 这三个内网IP。另一户人家一家四口，分别使用192.168.2.13,192.168.2.14,192.168.2.15,192.168.2.16这四个内网IP。
这7个内网IP都是在173.195.171.151这个外网IP之下的。即多个内网地址共用一个外网地址
当这些内网IP的设备和外界其他设备同信时，其实是使用的同一个外网IP 173.195.171.151和外界同信，而不是直接让某个外网IP和外界通信


端口
一个设备可能会有多个进程都会用到网络和外界进行通信。而一个进程会被分配一个端口作为这个进程和外界通信的接口。

当设备（内网IP为192.168.2.11，外网IP为173.195.171.151）的某个进程（使用端口6666）想和外界网络通信（例如一台手机使用浏览器访问淘宝官网假设访问的这个淘宝官网的IP是23.224.193.22），此时消息是从192.168.2.11:6666这个内网IP和端口发出，先发送到外网地址173.195.171.151所在的路由器设备，路由器设备通过 173.195.171.151:16666 这个IP和端口将消息转发给淘宝网站服务器。

接收消息的时候也是路由器(173.195.171.151:16666)先接收，再将消息转发会给192.168.2.11:6666这个设备的这个端口。

这种网络地址转换技术即使NAT技术。

用学术性的表达可以表达为：
NAT技术是一种在IP数据包通过路由器或防火墙时重写来源IP地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问因特网的私有网络中。

其原理是内网IP的消息在路由器被转发时，路由器替换IP报文头部的地址信息为外网IP的IP地址。

NAT技术好处是扩展了IP的个数，让设备有足够多的IP可以分配。
坏处是让主机之间的通信变得复杂，导致了通信效率的降低。


=======================================

ICMP协议
又称网络控制报文协议。

ICMP协议可以报告错误信息。

ICMP协议是封装在IP数据报的数据中的。包括ICMP报文首部和ICMP报文数据

ICMP报文的内容是错误报告或者询问报文

ICMP协议的应用

1.Ping应用
使用ping时，其ICMP的报文是询问报文。

通常ping会按顺序ping 3个地址：
a. ping 127.0.0.1  ping本机地址可以排查系统的网络协议是否正确。如果ping不通，请重装系统

b. ping 网关地址(即路由器地址，网关可以看出是一个大点的路由器)
如果ping不通，说明网线没接好或者路由器没插好电源

c. ping 远端地址  例如 ping www.baidu.com 
可以检测这个远程地址是否能够通信，以及通信的快慢


2.Traceroute应用
Traceroute可以探测IP数据包在网络中走过的路径

执行 traceroute www.baidu.com 会返回从本机IP到百度服务器IP过程中途径的IP。

===============================================

网络层的路由

路由器中有一个路由表记录着目的IP和下一跳IP的映射关系。
但是路由表中，下一跳地址是怎么来的
下一跳地址是不是唯一的
下一条地址是不是最佳的
路由器这么多，他们是怎么协调的

需要一个好的算法去解决这些事

我们可以使用图来描述一个网络。
其中一个顶点是一个网络，路由器或者计算机
每一条变代表一条网络路径

路由的算法实际上是图论的算法。


自治系统(AS)
一个AS是处于一个管理机构下（一个国家或一个城市或者一个学校或一个公司等）的网络设备群
AS内部网络自行管理，AS对外提供一个或者多个出口入口


自治系统内部路由的协议成为：内部网关协议
自治系统外部路由的协议成为：外部网关协议


关于内部网关协议和外部网关协议的部分这里略过


===========================================

传输层 


UDP协议详解

UDP 用户数据报协议
这里的数据报是指应用层直接传过来的数据报，UDP协议不会对其进行任何处理，不拆分也不合并

UDP协议下包含 UDP首部+UDP数据报的数据
其中UDP数据报的数据 = 应用层的数据，一点不多一点不少

所以UDP是一个简单的协议

UDP首部包含 16位的源端口号和16位目的端口号
即UDP首部包括两个要通信的进程的端口。即本机器的进程的端口和目的机器的进程的端口。

UDP是一个无连接的协议

即使用UDP协议通信 是无需在两个机器间建立连接的。意味着无需建立连接就可以发送请求


UDP不能保证可靠的交付数据，不能保证数据在网络中是否丢失，即使丢失了也不知道。

UDP是面向报文传输的

UDP没有拥塞控制

UDP首部开销很小（首部内容很少）


====================================

TCP协议详解

TCP 传输控制协议
这是一个非常复杂的协议

TCP协议包括 TCP首部+TCP数据报的数据

TCP是面向连接的协议
即发送请求前要先建立连接
TCP的一个连接有两端，是一个点对点的通信

TCP提供可靠的传输服务

TCP是种全双工的的通信（即两个计算机可以向双方发送数据）

TCP是面向字节流的协议（这意味着TCP的数据会分拆多次放到多次报文中传输）



TCP的头部包含源端口，目的端口，序号，确认号，数据偏移，保留字段，TCP标记（重要），窗口（重要），校验和，紧急指针，填充，TCP选项（可选）

序号
占32位
一个字节有一个序号
TCP头部的序号是指TCP数据报中数据第一个字节（首字节）的序号

确认号
占32位
确认号表示期望收到下一个TCP数据报的数据的首字节序号；也是滑动窗口中的第一个字节序号

例如一个TCP的数据报的数据首字节序号是501，数据长度为100字节。
那么确认号就是601，表示希望下一个收到的TCP数据报的首字节序号为601。

TCP标记
TCP标记是一个6位的二进制
其中每一位都有其含义

第一位：URG   紧急位，URG=1表示是紧急数据
第二位：ACK   确认位，ACK=1确认号才有效
第三位：PSH   推送位，PSH=1表示要尽快将数据交付给应用层
第四位：RST   重置位，RST=1，表示连接发生错误，重新建立连接
第五位：SYN   同部位，SYN=1，表示连接请求报文，用于同步连接
第六位：FIN    终止位，FIN=1 表示释放连接

例如 TCP标志位为 010010 就表示 URG=0,ACK=1,PSH=0,RST=1,SYN=1,FIN=0


窗口
占16位的二进制
窗口指明了滑动窗口的大小

例如 窗口的十进制是1000，表示滑动窗口的大小能容纳1000个字节的数据


紧急指针 
当URG=1时才会用到。

 
==================================

可靠传输的基本原理

将计算机分为发送方和接收方。

停止等待协议
发送方发送消息给接收方，消息方接收消息后会发送一个确认的信号给发送方，发送方才会发送下一个消息。
停止等待协议就是发送方发送完消息后，在接收到对方的确认信号前不会再发送新消息，而是会等待这个确认信号发过来


但是复杂的网络环境就会出现很多意外和差错的
情况1：发送方发送的网络报文丢失
一旦丢失，接收方就接收不到发送方的消息，也就不会发送确认信号。那么此时发送方不会一直等待，而是等待一会之后，重新发送之前的消息。这个叫做超时重传。

情况2：发送方发送的消息被接收方收到，但是接收方返回的确认信号丢失
此时发送方一样接收不到确认消息，照样会超时重传，发送方在一段时间后重新发送上一次的消息

情况3：接收方的确认信号没有丢失，但是在网络中逗留了很久才到达发送方
此时发送端照样会超时重传

所以停止等待协议是通过超时重传做到可靠传输的

为了判断确认信号的接收是否超时，发送端每发送一个消息都会设置一个定时器，这个定时器叫做 “超时定时器”


停止等待协议是简单的可靠传输协议。
但是等待协议对信道的利用效率不高，因为每次发送端发送消息都要等待确认消息返回才能发送下一个消息




连续ARQ协议
ARQ 自动重传请求

ARQ协议下，发送端发送消息报文是可以批量发送的。
也就是说停止等待协议下，发送端发送报文是一个个发送的，一次只能发送一个报文。而ARQ协议，发送端一次可以批量发送多个报文。

这里涉及到一个概念叫做滑动窗口。
滑动窗口限定已发送但未接受到确认消息的发送端报文的个数。

例如：发送端有100个报文要发送，这100个报文要排队排成一个队列。
滑动窗口的报文数为5。
那么一开始发送端会批量发送5个报文（1~5号报文）给接收方。
过了一会，1号2号报文的确认消息返回，3~5号的确认还未返回。此时发送端会在发送两个报文（6,7号报文）

这样一来滑动窗口中的报文始终保持在5个。

只要有报文的确认消息返回给发送端，滑动窗口就会往下滑动，发送后面的新消息报文给接收方


再介绍一个概念叫做累计确认
滑动窗口不会每接收到一个确认消息就往后滑动一个报文。而是检测到滑动窗口中的某个报文被确认了，那么久认为这个报文之前的报文都被确认了，这是滑动窗口会往下滑动多个报文。

例如一开始发送端会批量发送10个报文（1~10号报文）给接收方。此时1~4号报文被确认，滑动窗口没有去检测它们，当5号报文被确认，滑动窗口会往后移动5个报文。此时窗口中的报文是6~15号

因为每个报文被返回确认消息时滑动窗口都要检查一次，效率也是不高的

窗口的大小是被记录在TCP报文头部的。
=====================================

TCP协议的可靠传输

TCP的可靠传输是基于连续ARQ协议
TCP的滑动窗口是以字节为单位的（因为TCP是面向字节流的协议），而不是像上面说的以报文为单位的。

发送者要发送的字节排成一列，等待发送，滑动窗口内的字节会被批量发送到接受者。当某个字节被接受者接收并发出确认信号的时候，滑动窗口就会往后面的字节滑动去发送后面的字节给接收者。（TCP报文中的字节流中的每一个字节都有自己的序号）


关于可用窗口：
例如，窗口的大小有5个字节，此时窗口内包含5个字节，字节序号为23~27。
而且23~27号字节都已经发送给接收者。

之后，23,24号字节被确认，此时可用窗口为2个，另外3个字节属于已发送未确认字节。此时滑动窗口可以往后移动2个字节。


现在考虑一种情况：
滑动窗口内覆盖着23~27号字节，这5个字节都已经发送出去了。
但是之后只有25,27号字节被确认。
此时由于窗口的第一个字节23号字节没有被确认，所以滑动窗口无法往后滑动。
如果超时计时器的时间到了23号字节还没有被确认，此时23~27号字节会全部重新发送（传送）。
这么一来重传的效率就不高

所以说，滑动窗口必须按序被确认才可以往后滑动。


为了解决这个重传效率不高的问题，TCP提供了选择重传的功能。

选择重传是通过记录未被接收的字节的序号边界，然后重传这个序号边界内的所有字符。
例如记录的是1000号和1500号的序号，那么会重传1000~1500号的字节

TCP报文头部可以记录10个这样的序号边界。

从上面的过程中，可以看到TCP要发送的所有字节是排成一列去传输的，如果这一列包含了很多字节，一个TCP报文传输不过来，就会分成多个TCP报文传输。
每个TCP报文中的数据的传输是一个一个字节（或者多个字节多个字节的）传输的（以流的形式传输），就是因为滑动窗口是一个一个字节（或者多个字节多个字节）传输的。
假如滑动窗口的大小为1000个字节，而一个TCP报文的大小为100个字节，那么当窗口在往后滑动的过程中，字节一个个传到接收方，接收方接收到100个字节的时候就当做是接收到了一个TCP报文。之后接收方不会真的一个一个字节的返回确认信息，而是等一个TCP报文的字节都接收到了，才对这一个TCP报文的字节统一返回一个确认信息(是个ACK=1的报文)。

所以：
可以分多个TCP报文传输量大的字节数据。
报文的传输不是将字节打包成一个块发送的，而是以流的形式一个字节一个字节的（或者多个字节多个字节的）发送的
发送端不会对每一个字节都发送一个确认报文，而是对一个TCP报文内的所有字节统一发送确认报文，或者说，就是对发送方发送的这个TCP报文发送确认报文。这样这个报文内的所有字节都被确认，滑动窗口就会一次性往后滑动一个报文这么多字节的位置。




PS：
1.窗口的大小不是固定的，而是在传输过程中可以变化的
2.发送者的窗口大小是由接收者返回确认报文时决定的。

下面展现一个完整的接收方和发送方的传输过程。
1.发送方发送了一个序列号为1的报文，这个报文传输了100个字节的数据[seq=1,DATA]（表示发送了序列号为1~100的字节数据）
2.发送方的滑动窗口没有用完，所以再发送100个字节的数据，此时报文的序列号为101。[seq=101,DATA]（发送了序列号为101~200的字节）
3.接收方一次性确认这200字节的数据，发送一个确认消息给发送方[ACK=1,ack=201,rwnd=300]。
（
ACK=1表示这是个确认报文。

ack=201表示返回确认号为201，即告诉发送方的滑动窗口说“序号为1~200的字节都已经确认了，滑动窗口可以往后滑动了，滑动到窗口的第一个字节为序号201的字节那个位置”，此时201号之前的字节都是已被确认的字节

rwnd=300表示接收方限定发送方此时的可用窗口只有300个字节
）
4.发送方有发送两个报文，第一个报文100个字节，第二个报文200个字节（刚好用完了接收方限定的300个可用字节的窗口）[seq=301,DATA],[seq=401,DATA]
5.接收方对这两个报文统一发送一个确认报文[ACK=1,ack=601,rwnd=0]（表示序号601前的字节都已被确认，而且限定发送方的可用窗口为0个字节。即不让发送方发送数据了）

==================================

TCP协议的流量控制

流浪控制即接收方希望发送方发送的慢一些。

流量控制是使用滑动窗口来实现的。

假如现在是用户高并发的时段，建立了很多连接，每个连接要传输很多数据。此时客户端就是发送方，服务器就是接收方，服务器无法处理这么多请求。就可以通过滑动窗口来限制流量，减缓客户端的数据发送速度

例如上面的例子：
1.发送方发送了一个序列号为1的报文，这个报文传输了100个字节的数据[seq=1,DATA]（表示发送了序列号为1~100的字节数据）
2.发送方的滑动窗口没有用完，所以再发送100个字节的数据，此时报文的序列号为101。[seq=101,DATA]（发送了序列号为101~200的字节）
3.接收方一次性确认这200字节的数据，发送一个确认消息给发送方[ACK=1,ack=201,rwnd=300]。
（
ACK=1表示这是个确认报文。

ack=201表示返回确认号为201，即告诉发送方的滑动窗口说“序号为1~200的字节都已经确认了，滑动窗口可以往后滑动了，滑动到窗口的第一个字节为序号201的字节那个位置”，此时201号之前的字节都是已被确认的字节

rwnd=300表示接收方限定发送方此时的可用窗口只有300个字节
）
4.发送方有发送两个报文，第一个报文100个字节，第二个报文200个字节（刚好用完了接收方限定的300个可用字节的窗口）[seq=301,DATA],[seq=401,DATA]
5.接收方对这两个报文统一发送一个确认报文[ACK=1,ack=601,rwnd=0]（表示序号601前的字节都已被确认，而且限定发送方的可用窗口为0个字节。即不让发送方发送数据了）

这里发送方返回 rwnd=300，rwnd=0 的报文目的就是限制发送端可用窗口的大小从而达到限流

6.等接收方处理完毕数据后，接收方返回一个rwnd=1000的报文，此时发送端又可以继续发送数据

这就是流量控制的过程。

现在有一个特殊情况：
假如，接收方的rwnd=1000的报文丢失了，发送方就无法继续发送数据。这种报文的丢失是没有超时定时器来控制它重传的。因为超时定时器是仅用于数据报文的重传的。

所以设计出来一个坚持定时器。
当发送方接收到窗口为0的报文时，会启动坚持定时器
坚持定时器会控制发送方每个一段时间发送一个窗口探测报文来询问接收方是否扩大了窗口。
这样即使rwnd=1000的报文丢失了，发送方也会通过坚持定时器知道窗口已经调大了，从而继续发送数据


============================================

TCP的拥塞控制

我们将网络看成一条公路，当网络中的报文过多就会造成拥塞。

在一条数据链路中，例如：A的报文要发送给B，途中经过网络1，路由器1，路由器2，网络2，路由器3，最后才到达B
在这个过程中报文经过了很多设备，这条数据链路中的各个部分各个设备都可能成为网络传输的瓶颈，即有一个设备慢就会导致整个数据链路慢


拥塞控制和流量控制有什么不同
流量控制主要考虑点对点的通信量的控制（例如A和路由器1之间的报文传输）
拥塞控制考虑整个网络，是全局性的考虑（涉及A，路由器1~3，B这些机器）


怎样认为发生了拥塞：
报文超时则认为是拥塞 


拥塞控制的算法

慢启动算法：
有小到大逐渐增加发送数据量
每收到一个确认报文，就加1

例如：一开始，发送方只发送1个报文。如果接收方对这一个报文发送确认报文，发送方就知道这条数链路可容纳更多的一次性发送报文。所以第二次，发送方会一次性发送2个报文，如果两个报文也统一收到确认，下一次发送方会发送4个报文。
这个过程是按指数增长的。
一次性发送的报文数量增长到一个叫做“慢启动阈值”的数量就会维持这个数量的报文速度来进行发送。

其实即使到达了慢启动阈值，发送方一次性发送的报文还可能会增加，这就涉及到拥塞避免算法


拥塞避免算法
该算法的实现如下：发送方会维护一个拥塞窗口的变量，这个拥塞窗口是比慢启动阈值略大的。
当一次性发送的报文达到阈值，只要网络不拥塞，就会尝试着将这个拥塞窗口调大，一次性发送的报文会逐步+1

例如，慢启动阈值为16。当发送方一次性发送16个报文时依旧能在超时时间内收到确认（即不拥塞），那么拥塞窗口的大小会+1。下一次发送方可以一次性发送17个报文，如果还不拥塞下一次就发18个依次类推直到拥塞。

所以慢启动算法和拥塞避免算法是结合使用的。慢启动算法的报文量是指数增长，拥塞避免是线性增长。
=========================================

TCP连接的建立（3次握手）

回顾一下TCP标记中的ACK，SYN和FIN
ACK=1，确认号才生效
SYN=1，表示连接请求报文，用于向接收方请求建立连接
FIN=1 表示释放连接


连接建立的过程：
1.发送方主动和接收方建立连接
发送一个SYN=1的报文，表示请求建立一个连接。并且携带者自己的报文的序号x。报文初始序号x不是1，而是一个随机数[SYN=1,seq=x]

2.接收方打开TCP连接，返回一个[SYN=1,ACK=1,seq=y,ack=x+1]，SYN=1表示接收方请求发送方打开一个连接；ACK=1表示对步骤1中发送方报文的确认；seq=y是接收方这份报文的序号；ack=x+1表示希望下一次接收发送方的报文时报文的序号为x+1，也就是说希望下次发送方报文的数据是x+1号之后的字节数据。

3.发送方再发出一个[ACK=1,seq=x+1,ack=y+1]
ACK=1：发送方对接收方报文确认
seq=x+1：报文序号，说明该报文携带的数据是x+1之后的字节数据
ack=y+1：告诉接收方说接收方的下一个报文的序号应为y+1


通过这3次报文发送，双方打开了连接，同时同步了对方的序号(这也是三次握手的作用)

TCP连接建立的过程中发送方和接收方的状态：
在接收方接收到第一个报文之前，接收方处于监听(listen)状态

发送方发出第一个报文到接收到确认报文之间的状态是“同步已发送(sync-sent)”状态

接收方发出第一个报文到接收发送方的确认报文之间的状态是“同步已接收(sync-rcvd)”状态

发送方接收到接收方确认报文后的状态是“建立连接(established)”状态

接收方接收到确认报文后的状态是“建立连接(established)”状态

所以接收方接收到发送方请求连接报文的时候不会马上建立连接，而是要发送确认报文，让发送方先建立了连接，并接收到发送方的确认报文后才建立连接。
所以发送方是先于接收方建立连接的。

发送方是在第二次握手之后进入的连接状态。
接收方是在第三次握手后进入的连接状态。
只有接收方和发送方都进入连接状态才能够进行数据传输


一个重要的问题（笔试和面试常问）：
为什么双方建立连接需要三次握手而不是只要两次握手。
答：是为了防止已失效的连接请求报文传送到接收方，引起错误。


具体情况如下：
假如两次握手就能建立连接，其过程会是 A发送SYN=1给B后，B马上进入连接状态，B返回ACK=1，A收到后A进入连接状态。接收方B先于A进入连接状态

如果，A发送请求发送报文 X1 给B，但是这个报文在网络中传输了很久。此时A在超时时间内没有收到确认报文，就会再发一个请求发送报文X2。
X2比X1早到达接收方B。
B建立连接，B返回一个确认报文。

A接收到确认报文，A建立连接。

此时X1到达B，请求B建立连接，但是B已经进入连接，所以引起错误。

如果是3次握手，则在B接收到X2的时候，B还没有建立连接，B会发送一个对X2的确认报文给A。但是A已经进入连接状态，所以会忽略这个确认报文。


还有另一种说法：
这种说法是：
二次握手的情况下：
A发送连接请求报文给B，B马上进入连接状态，并发送给A一个确认报文。
但是这个确认报文可能会丢失，所以A就不会进入连接状态。
此时B进入连接状态，B就会一直等待A的数据传输过来，但是实际上A没有进入连接状态。

如果是三次握手就可以避免这种情况，因为如果第一个确认报文丢失，A没有进入连接状态，B会重发一个确认报文给A，这样能够确保让A进入连接状态。B接收到A的确认报文后也才进入连接状态。

又产生一个问题，如果B没有接收到A的确认报文，B就不能进入连接状态了，那不就变成A要等待B了吗?此时不就要使用4次握手了吗？那为什么有不使用4次握手建立连接呢？
因为，采取4次甚至N次握手会使建立连接的时间太长，效率低。


===============================================

TCP连接的释放（TCP的4次挥手）

1. 发送方发送 FIN=1,seq=u 的报文，表示发送方主动提出释放连接的请求报文。
发送方进入 “FIN-WAIT-1” 的等待状态（第一个等待状态）

2.接收方返回确认报文 ACK=1,seq=v,ack=u+1 表示确认接收到发送方的释放连接的请求报文
接收方进入“关闭等待”状态。关闭等待意思是我要等等才能关闭连接，为什么要等等才关闭连接呢？很可能是因为接收方没有把数据（服务端的响应数据）发送完。此时接收方还可以继续应用层的数据的发送

发送方接收到这个确认报文会进入 “FIN-WAIT-2” （第二个等待状态）

3.等接收方把响应数据都发送完了之后，就会发送一个 FIN=1,ACK=1,seq=w,ack=u+1 的报文。这个报文表示对发送方的第一个报文进行再一次确认，并且自己也发送释放连接的请求。
接收方进入“最后确认(LAST-ACK)”的状态

4. 发送方接收到接收方第二个ACK确认报文后才会结束FIN-WAIT-2的状态，然后发送一个ACK=1,,seq=u+1,ack=w+1的报文，表示对接收方的释放连接请求确认。
发送方会进入TIME-WAIT状态，并设置一个等待计时器。等待计时器会计时2个最长报文寿命时长（2MSL约等于4分钟）才结束TIME-WAIT状态

而接收方接收到发送方的确认报文会直接进入关闭状态

但发送方要等待TIME-WAIT状态结束后才会进入关闭状态

在TIME-WAIT状态下，客户端的这个连接的端口是不会被释放的。也就是说客户端无法通过这个端口再建立一个新连接。即这个状态下，这个端口不能复用。


一个很重要的问题：
为什么需要有TIME-WAIT状态呢？
答：
1.
是为了确保发送方的最后一个报文即确认报文被接收方接收到了，从而接收方正确关闭连接。
假如这个确认报文丢失，接收方没有收到，就不会正确关闭连接。
接收方会重新发一个释放连接请求报文（FIN=1的报文），给发送方。

关键来了，假如发送方没有TIME-WAIT状态，而是直接进入关闭状态，发送方就无法再接收到接收方第二次发送的FIN=1报文了。
这就导致接收方无法关闭连接

2.确保当前连接的所有报文都已经过期
因为TIME-WAIT 会等待2MSL的时间，所以这个时间内，前面所有的可能存在网络延迟而无法准时达到接收方或发送方的报文都会因为达到报文寿命而消逝。

以防止这些延迟报文被已经建立了新连接的发送方或接收方接收到导致新连接被破坏或者干扰


=========================

套接字和套接字编程

我们使用端口来标记不同的网络进程
端口使用16个位表示，所以端口范围是0~65535

套接字就是这个一台计算机的IP加端口： 例如 23.224.23.233:80 就是一个套接字

套接字（socket）是一个抽象概念，它其实表示的是TCP连接的一端（发送端或接收端）

通过套接字可以进行数据的发送或接收。
而通过tcp连接可以进行数据的传输
一个tcp由两个套接字组成（发送方套接字和接收方套接字）

那么数据的发送，传输和接收分别是由 发送端套接字，tcp连接，接收方套接字来完成的


套接字编程的过程

服务端：
创建服务端套接字-->进程绑定套接字-->监听套接字-->接收和处理数据

客户端：
创建客户端套接字-->连接服务端的套接字（TCP三次握手在此发生）-->发送信息

以下是用python实现的一个简单的套接字连接：
#服务端
# coding=utf-8

import socket

def server():
    # 创建套接字
    s = socket.socket()
    host = "127.0.0.1"
    port = 6666

    # 绑定端口
    s.bind((host,port))

    # 监听端口
    s.listen(5)     # 最多允许5个并发连接

    while True:
        sock,addr = s.accept()   # 接收客户端的数据报文（这里会阻塞）,返回一个客户端套接字和客户端地址，客户端地址包括客户端ip和端口
        print("Connect Addr:" , addr)
        sock.send(b"Welcome to zbpblog!")     # 通过这个客户端套接字发送数据给客户端,这里要发送byte字节类型不能发送str类型
        sock.close()                         # 关闭连接

if __name__ == "__main__":  
    server()        # 运行服务端
    
    
PS：上面一共有两个套接字：s是服务端用于监听IP和端口的套接字；sock是客户端的套接字。一旦接受到有客户端发送过来的数据包就会获取到这个客户端sock；
    
# 客户端
# coding=utf-8

import socket

def client(i):
    # 创建一个套接字
    s = socket.socket()

    # 连接服务端的套接字
    s.connect(("127.0.0.1",6666))

    # 接收返回的数据数据
    print("Recv msg:%s ; Client:%s" % (s.recv(1024),i))     # 限定长度为1024字节

    s.close()

if __name__ == "__main__":
    for i in range(5):
        client(i)

PS：请不要在pycharm中同时运行服务端和客户端，而是在pycharm运行客户端，在cmd中运行服务端。请先运行服务端，后运行客户端。 

对比一下网络套接字和域套接字
使用网络套接字通信需要经过协议栈，也就是要经过传输层，网络层，物理层，路由器，物理层，网络层，传输层。即使你是单机不同端口的通信，也会经过路由器和协议栈。

而域套接字是通过一个域套接字文件进行通信，无需经过协议栈。

所以，单机不同端口的通信最后使用域套接字进行，效率高。
而两台不同的机器通信只能通过网络套接字进行。

==========================================

应用层 

DNS详解
DNS（域名系统）

我们知道，要访问一个网络服务可以访问 ip:port 来访问。
例如 23.224.25.233:80 访问的是23.224.25.233的一个网站

但是对于用户来说，ip和端口不好记，所以推出了DNS

DNS服务就是将域名转换为ip和port，然后再去访问 ip:port 对应的网络进程服务


域名由点，字符和数字组成
点分割不同的域
域名可以分为顶级域，二级域和三级域。

例如 www.baidu.com 这个域名有三个域；com是顶级域，baidu是二级域，www是三级域

顶级域分为国家和通用两类：
国家如： cn,us,uk,ca
通用如：com,net,org,gov

二级域如：
qq,taobao ,google,baidu 等等很多很多


顶级域下有很多二级域，呈现一个树状结构

DNS服务是部署在服务器上的，这个服务器是域名服务器，域名服务器是国家或者机构部署的。
DNS服务可以将域名转为IP再通信。


域名服务器也是一个树状结构，在顶层有一个根域名服务器，根域名服务器下有很多顶级域名服务器，顶级域名服务器下有很多地区性的域名服务器

根域名服务器存储着各个顶级域的信息是记录在哪个顶级域名服务器。
而顶级域名服务器记录着某个顶级域名下的二级域名是记录在哪个地区域名服务器

如果用电脑访问一个域名，会先在本地域名服务器中查找这个域名对应的IP和端口。如果找不到就会去根域名服务器找这个域名的顶级域是在哪个顶级域名服务器，再到顶级域名服务器找这个域名的二级域是对应的哪个地区域名服务器，最后在地区域名服务器找到了这个域名的IP和端口。这样一层层的往下找。

这个域名和IP:port的映射会被缓存到本地域名服务器。下次就直接在本地域名服务器找就可以


==========================================

DHCP协议

DHCP 动态主机设置协议
DHCP是一个局域网
DHCP是应用UDP协议的应用层协议

我们知道，我们的手机，电脑是不用自行配置IP地址就可以上网。这就是DHCP提供的一种“即插即用联网”的功能

现在window中使用 “自动获取IP地址” 就是DHCP的作用。它会分配一个临时的IP给你的设备使用。

首先有一个DHCP服务器
当我的主机希望被分配一个随机IP的时候，主机会使用UDP协议广播“DHCP发现报文”（报文的ip是1.1.1.1）
DHCP服务器接收到报文后会发一个DHCP提供报文给主机，表示可以为主机提供DHCP服务
主机就会向DHCP服务器发出DHCP请求报文
DHCP服务器回应并提供IP给我的主机

这个过程是在局域网中进行的。

=============================================

HTTP协议详解

HTTP 超文本传输协议

http地址：
http(s)://<主机>:<端口>/<路径>
其中主机可以是IP或者域名
端口一般是80或者443

HTTP协议是基于TCP协议实现的。

Web服务器
Web服务器包括硬件和软件部分。
硬件就是一台计算机
软件常用的有Nginx和Apache

下面主要讨论软件部分，即web服务是如何接受和处理请求的
1.Web服务器要先接收客户端的(tcp)连接
2.Web服务器接收请求(报文)
3.Web服务器处理请求
4.Web服务器获取Web资源
5.Web服务器构造响应并发送响应

步骤1的过程在传输层的TCP三次握手时已经介绍过

步骤2
HTTP请求有很多请求方法
下面介绍几个主要的方法
GET     获取指定的服务端资源
POST    提交数据到服务端
DELETE  删除指定的服务端资源
UPDATE  更新指定的服务端资源

如何找到 “指定的资源”
A 在url地址中指定（很常见如 https://abc.com/article/20334.html）

B 在请求的数据中指定
就是将参数写在请求报文的请求体中

在这里我们需要对HTTP的请求和响应报文进行一定的了解

HTTP请求报文分为3部分：
请求行： 形式为 [请求方法][请求地址][HTTP版本]
例如 GET /data/info.html HTTP/1.1

请求头
例如：
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cache-Control: max-age=0
Connection: keep-alive
Cookie: Hm_lvt_080836300300be57b7f34f4b3e97d911=1583639375,1584365760,1584402496,1584768625; Hm_lvt_4898023a3a963db158d0eeee27c56c80=1584365739,1584402481,1584768610,1585483732; Hm_lpvt_4898023a3a963db158d0eeee27c56c80=1585483732
Host: zbpblog.com
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: none
Sec-Fetch-User: ?1
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36
他是一个key-value的形式


请求内容（请求体）
若方法字段是GET，则此项为空，没有数据

若方法字段是POST,则请求内容就是要提交的数据

比如 user=admin&password=123456 ，使用&来连接各个字段，这是以文本的格式作为请求体
还可以以json等格式来作为请求体

报文内容如下图所示：


HTTP响应报文分为3部分：
响应行  形式为 [HTTP版本][状态码][状态解释]
如 HTTP/1.1 200 OK

响应头
如 
Connection: Keep-Alive
Content-Type: text/html; charset=utf-8
Date: Sun, 29 Mar 2020 12:08:55 GMT
Keep-Alive: timeout=5, max=97
Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/7.2.22
Transfer-Encoding: chunked
X-Powered-By: PHP/7.2.22

响应内容（体）
就是纯数据，例如html静态文件的内容，或者是json格式的数据内容

=====================================

HTTPS详解

HTTP是明文传输的。所以用HTTP传输数据是不安全的。

HTTPS是安全的HTTP协议


加密模型
有对称加密和非对称加密两种

对称加密
数据在客户端使用密钥加密，在服务端使用同一把密钥解密
两个密钥是相同的

非对称加密
数据在客户端使用密钥A（公钥）加密，在服务端使用另一把密钥B（私钥）解密
但是A,B是拥有一定数学关系的一组密钥
其中一把叫做私钥，另一把叫做公钥

密钥和公钥私钥的关系：密钥包含公钥和私钥两种

使用公钥加密后的数据（密文）只能够用私钥解密，不能用公钥解密

上面的过程中，服务器向客户端发送数据时是服务端加密，客户端解密
服务端和客户端都可以进行加密和解密

数字证书
是一个组织机构给特定对象的认证

数据证书的内容：证书序列号，签名算法，有效期，对象名称（一般是域名），对象公钥

所以证书中是有公钥的，但是没有私钥。你可以就认为数字证书就是公钥
私钥是另外保存在一个私钥文件中的

数字证书和私钥文件都保存在服务器上的。

例如 
zbpblog.com.crt 这个 .crt 文件就是数字证书文件
zbpblog.com.key 这个 .key 文件就是密钥文件


SSL（安全套接层）
SSL层是介于应用层和传输层之间的一个子层
数据的加密和解密就是在SSL层完成的
所以如果使用了https，那么数据到达传输层时就已经是加密后的数据


相比于HTTP发送请求的过程，HTTPS也一样都是建立连接，发送请求，返回响应。但是HTTPS在建立连接和发送请求之间多了一步“SSL安全参数握手”的步骤

SSL安全参数握手的过程：
1.客户端生成一个随机数1。客户端将随机数1，协议版本，采用哪种加密算法发送给服务端
2.服务器生成一个随机数2，返回一个确认报文给客户端，报文内容包括确认 确认采用哪种加密算法，数字证书和随机数2
公钥在数字证书中，所以公钥其实就被传给了客户端

假设公钥是X

3.客户端接收到确认报文后，确认证书是否有效，然后生成随机数3，使用证书中的公钥X对随机数3加密

然后客户端将加密后的随机数3发送给服务端

服务端通过密钥对随机数3进行解密从而获取随机数3的明文

4.现在客户端，服务端都有了随机数1~3的明文。
双方都根据随机数1~3和相同的算法生成一个对称密钥

注意，这个对称密钥是没有经过传输的，所以减少了密钥泄漏的可能

5.客户端将请求数据通过对称密钥加密，传输给服务端，服务端通过对称密钥解密。

所以 HTTPS 是综合使用了对称加密和非对称加密两种加密模式的。


至此，TCP/IP 四层模型就已经粗略的介绍完毕

下面使用python搭建一个简单的服务器作为实践

=====================================

搭建服务基本框架(报文解析器)

在此之前介绍几个概念

网卡模式：
混杂模式：接受所有经过网卡设备的数据
非混杂模式：只接受目的地址指向自己的数据

字节序
字节序是指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。

字节序有大端字节序和小端字节序两种：
例如 有一个字符串 DEAD
其二进制为：
01000100 01000101 01000001 01000100

一共4个字节。从左到右是高位字节到低位字节

大端字节序是字节排序是高位字节在前面，低位字节在后面。这也符合我们人类的思维。

小端字节序是字节排序是低位字节在前面，高位字节在后面。CPU运算的时候就是按照小端字节序来排序的。
所以在CPU或者内存中，DEAD的字节序为
01000100 01000001 01000101 01000100 
    D        A        E        D 


网络中的字节流则是以大端字节序来对字节排序的。



python的struct包
可以使用struct包来对字节流进行处理

格式字符
B    整数      1个字节（将1个字节变为整型）
H    整数      2个字节（将2个字节变为1个整型）
L    整数      4个字节（将4个字节变为1个整型）
s    字符串    -      

例如
import struct

content = b"BDACCEAB"
print(struct.unpack(">BBBBBBBB",content))
print(struct.unpack("<BBBBBBBB",content))
print(struct.unpack(">HHHH",content))
print(struct.unpack("<HHHH",content))
print(struct.unpack(">LL",content))
print(struct.unpack("<LL",content))
print(struct.unpack("ssssssss",content))

content是一个8个字节的字节类型

>BBBBBBBB中的 >表示以大端字节序表示，BBBBBBBB表示将content中的字节用8个整型表示
得到：(66, 68, 65, 67, 67, 69, 65, 66)
刚好是content中每一个字节的ASCII码

<BBBBBBBB 是以小端字节序表示
得到：(66, 68, 65, 67, 67, 69, 65, 66)
和用大端字节序表示一样的结果


>HHHH 表示用四个整数表示content中的8个字节
它的结果是：(16964, 16707, 17221, 16706)
这个是这么来的：
(66, 68, 65, 67, 67, 69, 65, 66)的二进制分别为
01000010 01000100 01000001 01000001 01000001 01000101 01000001 01000010 

变成4个二进制就是将上面的二进制两两相连
0100001001000100 0100000101000001 0100000101000101 0100000101000010

就可以得到 16964, 16707, 17221, 16706


<HHHH 的结果是：
(17474, 17217, 17731, 16961)

小端字节序是将一个整数中的两个字节顺序反过来，就变成了：(68, 66, 67, 65, 69, 67, 66, 65)
再按照上面的做法变成二进制，最后两两连在一起得到的这个结果

>LL和<LL就同理可得 (1111769411, 1128612162) 和 (1128350786, 1111573827)



接下来正式写一个简单的报文处理服务器
这个框架是基于之前的线程池来实现的。


# Server.py
# coding=utf-8

import socket
import os,sys,json

sys.path.append("..")

from ThreadTool.ThreadPool import ThreadPool as tp
from ThreadTool.Task import AsyncTask
from IPParser import IPParser
from UDPParser import UDPParser

class ProcessTask(AsyncTask):
    def __init__(self,packet,*args,**kwargs):
        self.packet=packet
        super(ProcessTask, self).__init__(func=self.process,*args,**kwargs)

    # 定义任务函数
    def process(self):
        headers={
            "network_header":None,      # 网络层报文的头部
            "transport_header":None     # 传输层报文的头部
        }
        ip_header = IPParser.parse(self.packet)
        headers['network_header'] = ip_header

        if ip_header['protocol']==17:
            udp_header = UDPParser.parse(self.packet)
            headers["transport_header"]=udp_header

        return headers



class Server:
    def __init__(self):
        # 使用ipv4协议，套接字类型为原始套接字，工作协议是IP协议(意味着下面接收到的包packet已经给你处理成是IP数据包)
        self.sock = socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_IP)

        # 绑定IP和端口
        self.ip = "192.168.0.106"   # 设置服务器的IP，就是自己这台电脑的IP
        self.port = 80
        self.sock.bind((self.ip,self.port))

        # 使用网卡模式为混杂模式
        self.sock.ioctl(socket.SIO_RCVALL,socket.RCVALL_ON)

        # 创建线程池和10个线程
        self.pool = tp(10)

        # 启动线程,等待任务进入队列
        self.pool.start()

    def loop_server(self):
        # 不停的接收报文，限定每65535为一个报文。将报文做成任务放到任务队列处理交给线程池中的线程处理
        # 也就是说报文的处理是多线程的是并发的
        while True:
            packet,addr = self.sock.recvfrom(65535)

            # 一个报文的解析作为一个任务
            task = ProcessTask(packet)

            # 任务放入队列
            self.pool.put_task(task)

            # 获取任务处理结果
            result = task.get_result()
            result = json.dumps(    # 格式化一下结果
                result,
                indent=4    # 缩进4个字节
            )

if __name__ == "__main__":
    server = Server()
    server.loop_server()    # 启动服务，监听和接收报文
    
    
    
    

# IPParser.py
# coding=utf-8

import struct,socket

# IP报文解析器
class IPParser:
    IP_HEADER_LENGTH=20     # IP 报文头部的长度是固定的，20个字节

    @classmethod
    def parse_ip_header(cls,ip_header):
        """
        IP 报文格式（IP报文头部的每一行都有32位长度，即4个字节）
        头部第1行 4位IP-Version 4位IP头长度 8位服务类型 16位总长度
        头部第2行 16位标识符  3位标记位 3位片偏移
        头部第3行 8位TTL  8位协议   16位IP头校验和
        头部第4行 32位源IP地址
        头部第5行 32位目的IP地址

        这里需要解析第1,3,4,5行的内容
        报文中的以上信息全部都是用二进制表示的
        """

        # struct最小只能解析一个字节，也就是8位，无法直接解析4位

        # 解析第一行,ip_header[:4]是获取报文头部的前四个4截，也即是第一行
        line1 = struct.unpack(">BBH",ip_header[:4])  # 返回一个3个元素的元组,三个元素分别是8个位(一个字节)，8个位和16个位（2个字节）的数据
        ip_version=line1[0] >> 4   # line[0]包含了八个位，我想获取前4个位需要做二进制的位移操作(获取到的二进制位会自动转为10进制)
        iph_length=line1[0] & 15   # line[0]中的8个位和 00001111 （15） 做与运算即可获取后4个位的二进制(会自动转为10进制)
        packet_length=line1[2]

        # 解析第三行
        line3 = struct.unpack(">BBH",ip_header[8:12])
        TTL = line3[0]
        protocol = line3[1]
        iph_checksum = line3[2]

        # 解析第四第五行
        line4 = struct.unpack(">4s",ip_header[12:16])   # 返回一个只有一个元素的元组
        line5 = struct.unpack(">4s",ip_header[16:20])
        src_ip = socket.inet_ntoa(line4[0])     # 将byte类型的二进制转为点分十进制的IP
        des_ip = socket.inet_ntoa(line5[0])

        # 返回以下信息,得到的以下信息都会被unpack转为10进制
        return {
            'ip_version':ip_version,
            'iph_length':iph_length,
            "packet_length":packet_length,    # 数据包数总长度
            "TTL":TTL,         # 过期次数
            "protocol":protocol,     # 报文的协议(TCP/UDP/...),6是TCP，17是UDP
            "iph_checksum":iph_checksum,     # 校验和
            "src_ip":src_ip,          # 源IP
            "des_ip":des_ip       # 目的IP
        }

    @classmethod
    def parse(cls,packet):
        ip_header = packet[:cls.IP_HEADER_LENGTH]

        return cls.parse_ip_header(ip_header)
        
        
        


# UDPParser.py
# coding=utf-8

import struct

# UDP 报文解析器

class UDPParser:
    IP_HEADER_LENGTH=20
    UDP_HEADER_LENGTH=8

    """
    UDP头部共8个字节的长度
    第一行 16为源端口 16位目的端口
    第二行 16位UDP数据长度 16位校验和
    """
    @classmethod
    def parse_udp_header(cls,udp_header):
        udp_header = struct.unpack(">HHHH",udp_header)

        return {
            "src_port":udp_header[0],
            "des_port":udp_header[1],
            "udp_length":udp_header[2],
            "udp_checksum":udp_header[3]
        }

    @classmethod
    def parse(cls,packet):
        # 这个packet还是ip数据包，udp或者tcp数据包是放在IP报文内容中的
        # packet的前20个字节是ip报文头部，所以20个字节后的内容就是TCP或UDP的内容
        udp_header = packet[cls.IP_HEADER_LENGTH:cls.IP_HEADER_LENGTH+cls.UDP_HEADER_LENGTH]

        return cls.parse_udp_header(udp_header)



# TCP 报文解析器可以依法编写